/*
ReportPortal

ReportPortal API documentation

API version: develop-322
Contact: support@reportportal.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// UserAPIService UserAPI service
type UserAPIService service

type ApiChangePasswordRequest struct {
	ctx              context.Context
	ApiService       *UserAPIService
	changePasswordRQ *ChangePasswordRQ
}

func (r ApiChangePasswordRequest) ChangePasswordRQ(changePasswordRQ ChangePasswordRQ) ApiChangePasswordRequest {
	r.changePasswordRQ = &changePasswordRQ
	return r
}

func (r ApiChangePasswordRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.ChangePasswordExecute(r)
}

/*
ChangePassword Change own password

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChangePasswordRequest
*/
func (a *UserAPIService) ChangePassword(ctx context.Context) ApiChangePasswordRequest {
	return ApiChangePasswordRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *UserAPIService) ChangePasswordExecute(r ApiChangePasswordRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.ChangePassword")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/password/change"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.changePasswordRQ == nil {
		return localVarReturnValue, nil, reportError("changePasswordRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.changePasswordRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateApiKeyRequest struct {
	ctx        context.Context
	ApiService *UserAPIService
	userId     int64
	apiKeyRQ   *ApiKeyRQ
}

func (r ApiCreateApiKeyRequest) ApiKeyRQ(apiKeyRQ ApiKeyRQ) ApiCreateApiKeyRequest {
	r.apiKeyRQ = &apiKeyRQ
	return r
}

func (r ApiCreateApiKeyRequest) Execute() (*ApiKeyRS, *http.Response, error) {
	return r.ApiService.CreateApiKeyExecute(r)
}

/*
CreateApiKey Create new Api Key for current user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId
	@return ApiCreateApiKeyRequest
*/
func (a *UserAPIService) CreateApiKey(ctx context.Context, userId int64) ApiCreateApiKeyRequest {
	return ApiCreateApiKeyRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return ApiKeyRS
func (a *UserAPIService) CreateApiKeyExecute(r ApiCreateApiKeyRequest) (*ApiKeyRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiKeyRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.CreateApiKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{userId}/api-keys"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKeyRQ == nil {
		return localVarReturnValue, nil, reportError("apiKeyRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiKeyRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateUserRequest struct {
	ctx                 context.Context
	ApiService          *UserAPIService
	uuid                *string
	createUserRQConfirm *CreateUserRQConfirm
}

func (r ApiCreateUserRequest) Uuid(uuid string) ApiCreateUserRequest {
	r.uuid = &uuid
	return r
}

func (r ApiCreateUserRequest) CreateUserRQConfirm(createUserRQConfirm CreateUserRQConfirm) ApiCreateUserRequest {
	r.createUserRQConfirm = &createUserRQConfirm
	return r
}

func (r ApiCreateUserRequest) Execute() (*CreateUserRS, *http.Response, error) {
	return r.ApiService.CreateUserExecute(r)
}

/*
CreateUser Activate invitation and create user in system

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateUserRequest
*/
func (a *UserAPIService) CreateUser(ctx context.Context) ApiCreateUserRequest {
	return ApiCreateUserRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CreateUserRS
func (a *UserAPIService) CreateUserExecute(r ApiCreateUserRequest) (*CreateUserRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateUserRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.CreateUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/registration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uuid == nil {
		return localVarReturnValue, nil, reportError("uuid is required and must be specified")
	}
	if r.createUserRQConfirm == nil {
		return localVarReturnValue, nil, reportError("createUserRQConfirm is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "uuid", r.uuid, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createUserRQConfirm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateUserBidRequest struct {
	ctx          context.Context
	ApiService   *UserAPIService
	createUserRQ *CreateUserRQ
}

func (r ApiCreateUserBidRequest) CreateUserRQ(createUserRQ CreateUserRQ) ApiCreateUserBidRequest {
	r.createUserRQ = &createUserRQ
	return r
}

func (r ApiCreateUserBidRequest) Execute() (*CreateUserBidRS, *http.Response, error) {
	return r.ApiService.CreateUserBidExecute(r)
}

/*
CreateUserBid Register invitation for user who will be created

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateUserBidRequest
*/
func (a *UserAPIService) CreateUserBid(ctx context.Context) ApiCreateUserBidRequest {
	return ApiCreateUserBidRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CreateUserBidRS
func (a *UserAPIService) CreateUserBidExecute(r ApiCreateUserBidRequest) (*CreateUserBidRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateUserBidRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.CreateUserBid")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/bid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createUserRQ == nil {
		return localVarReturnValue, nil, reportError("createUserRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createUserRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateUserByAdminRequest struct {
	ctx              context.Context
	ApiService       *UserAPIService
	createUserRQFull *CreateUserRQFull
}

func (r ApiCreateUserByAdminRequest) CreateUserRQFull(createUserRQFull CreateUserRQFull) ApiCreateUserByAdminRequest {
	r.createUserRQFull = &createUserRQFull
	return r
}

func (r ApiCreateUserByAdminRequest) Execute() (*CreateUserRS, *http.Response, error) {
	return r.ApiService.CreateUserByAdminExecute(r)
}

/*
CreateUserByAdmin Create specified user

Allowable only for users with administrator role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateUserByAdminRequest
*/
func (a *UserAPIService) CreateUserByAdmin(ctx context.Context) ApiCreateUserByAdminRequest {
	return ApiCreateUserByAdminRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CreateUserRS
func (a *UserAPIService) CreateUserByAdminExecute(r ApiCreateUserByAdminRequest) (*CreateUserRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateUserRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.CreateUserByAdmin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createUserRQFull == nil {
		return localVarReturnValue, nil, reportError("createUserRQFull is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createUserRQFull
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteApiKeyRequest struct {
	ctx        context.Context
	ApiService *UserAPIService
	keyId      int64
	userId     int64
}

func (r ApiDeleteApiKeyRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.DeleteApiKeyExecute(r)
}

/*
DeleteApiKey Delete specified Api Key

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param keyId
	@param userId
	@return ApiDeleteApiKeyRequest
*/
func (a *UserAPIService) DeleteApiKey(ctx context.Context, keyId int64, userId int64) ApiDeleteApiKeyRequest {
	return ApiDeleteApiKeyRequest{
		ApiService: a,
		ctx:        ctx,
		keyId:      keyId,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *UserAPIService) DeleteApiKeyExecute(r ApiDeleteApiKeyRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.DeleteApiKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{userId}/api-keys/{keyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"keyId"+"}", url.PathEscape(parameterValueToString(r.keyId, "keyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteUserRequest struct {
	ctx        context.Context
	ApiService *UserAPIService
	id         int64
}

func (r ApiDeleteUserRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.DeleteUserExecute(r)
}

/*
DeleteUser Delete specified user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiDeleteUserRequest
*/
func (a *UserAPIService) DeleteUser(ctx context.Context, id int64) ApiDeleteUserRequest {
	return ApiDeleteUserRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *UserAPIService) DeleteUserExecute(r ApiDeleteUserRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.DeleteUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteUsersRequest struct {
	ctx        context.Context
	ApiService *UserAPIService
	ids        *[]int64
}

func (r ApiDeleteUsersRequest) Ids(ids []int64) ApiDeleteUsersRequest {
	r.ids = &ids
	return r
}

func (r ApiDeleteUsersRequest) Execute() (*DeleteBulkRS, *http.Response, error) {
	return r.ApiService.DeleteUsersExecute(r)
}

/*
DeleteUsers Delete specified users by ids

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteUsersRequest
*/
func (a *UserAPIService) DeleteUsers(ctx context.Context) ApiDeleteUsersRequest {
	return ApiDeleteUsersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DeleteBulkRS
func (a *UserAPIService) DeleteUsersExecute(r ApiDeleteUsersRequest) (*DeleteBulkRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeleteBulkRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.DeleteUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	{
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEditUserRequest struct {
	ctx        context.Context
	ApiService *UserAPIService
	login      string
	editUserRQ *EditUserRQ
}

func (r ApiEditUserRequest) EditUserRQ(editUserRQ EditUserRQ) ApiEditUserRequest {
	r.editUserRQ = &editUserRQ
	return r
}

func (r ApiEditUserRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.EditUserExecute(r)
}

/*
EditUser Edit specified user

Only for administrators and profile's owner

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param login
	@return ApiEditUserRequest
*/
func (a *UserAPIService) EditUser(ctx context.Context, login string) ApiEditUserRequest {
	return ApiEditUserRequest{
		ApiService: a,
		ctx:        ctx,
		login:      login,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *UserAPIService) EditUserExecute(r ApiEditUserRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.EditUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{login}"
	localVarPath = strings.Replace(localVarPath, "{"+"login"+"}", url.PathEscape(parameterValueToString(r.login, "login")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.editUserRQ == nil {
		return localVarReturnValue, nil, reportError("editUserRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.editUserRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportRequest struct {
	ctx                         context.Context
	ApiService                  *UserAPIService
	view                        *string
	filterEqFullName            *string
	filterEqUuid                *string
	filterEqEmail               *string
	filterEqId                  *int32
	filterEqRole                *string
	filterEqSynchronizationDate *int32
	filterEqExpired             *bool
	filterEqProject             *[]interface{}
	filterEqType                *string
	filterEqUser                *string
	filterEqActive              *bool
	filterEqLastLogin           *int32
	filterEqExternalId          *string
	filterEqProjectId           *int32
}

func (r ApiExportRequest) View(view string) ApiExportRequest {
	r.view = &view
	return r
}

// Filters by &#39;fullName&#39;
func (r ApiExportRequest) FilterEqFullName(filterEqFullName string) ApiExportRequest {
	r.filterEqFullName = &filterEqFullName
	return r
}

// Filters by &#39;uuid&#39;
func (r ApiExportRequest) FilterEqUuid(filterEqUuid string) ApiExportRequest {
	r.filterEqUuid = &filterEqUuid
	return r
}

// Filters by &#39;email&#39;
func (r ApiExportRequest) FilterEqEmail(filterEqEmail string) ApiExportRequest {
	r.filterEqEmail = &filterEqEmail
	return r
}

// Filters by &#39;id&#39;
func (r ApiExportRequest) FilterEqId(filterEqId int32) ApiExportRequest {
	r.filterEqId = &filterEqId
	return r
}

// Filters by &#39;role&#39;
func (r ApiExportRequest) FilterEqRole(filterEqRole string) ApiExportRequest {
	r.filterEqRole = &filterEqRole
	return r
}

// Filters by &#39;synchronizationDate&#39;
func (r ApiExportRequest) FilterEqSynchronizationDate(filterEqSynchronizationDate int32) ApiExportRequest {
	r.filterEqSynchronizationDate = &filterEqSynchronizationDate
	return r
}

// Filters by &#39;expired&#39;
func (r ApiExportRequest) FilterEqExpired(filterEqExpired bool) ApiExportRequest {
	r.filterEqExpired = &filterEqExpired
	return r
}

// Filters by &#39;project&#39;
func (r ApiExportRequest) FilterEqProject(filterEqProject []interface{}) ApiExportRequest {
	r.filterEqProject = &filterEqProject
	return r
}

// Filters by &#39;type&#39;
func (r ApiExportRequest) FilterEqType(filterEqType string) ApiExportRequest {
	r.filterEqType = &filterEqType
	return r
}

// Filters by &#39;user&#39;
func (r ApiExportRequest) FilterEqUser(filterEqUser string) ApiExportRequest {
	r.filterEqUser = &filterEqUser
	return r
}

// Filters by &#39;active&#39;
func (r ApiExportRequest) FilterEqActive(filterEqActive bool) ApiExportRequest {
	r.filterEqActive = &filterEqActive
	return r
}

// Filters by &#39;lastLogin&#39;
func (r ApiExportRequest) FilterEqLastLogin(filterEqLastLogin int32) ApiExportRequest {
	r.filterEqLastLogin = &filterEqLastLogin
	return r
}

// Filters by &#39;externalId&#39;
func (r ApiExportRequest) FilterEqExternalId(filterEqExternalId string) ApiExportRequest {
	r.filterEqExternalId = &filterEqExternalId
	return r
}

// Filters by &#39;projectId&#39;
func (r ApiExportRequest) FilterEqProjectId(filterEqProjectId int32) ApiExportRequest {
	r.filterEqProjectId = &filterEqProjectId
	return r
}

func (r ApiExportRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExportExecute(r)
}

/*
Export Exports information about all users

Allowable only for users with administrator role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiExportRequest
*/
func (a *UserAPIService) Export(ctx context.Context) ApiExportRequest {
	return ApiExportRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UserAPIService) ExportExecute(r ApiExportRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.Export")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.view != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view", r.view, "form", "")
	}
	if r.filterEqFullName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.fullName", r.filterEqFullName, "form", "")
	}
	if r.filterEqUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.uuid", r.filterEqUuid, "form", "")
	}
	if r.filterEqEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.email", r.filterEqEmail, "form", "")
	}
	if r.filterEqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.id", r.filterEqId, "form", "")
	}
	if r.filterEqRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.role", r.filterEqRole, "form", "")
	}
	if r.filterEqSynchronizationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.synchronizationDate", r.filterEqSynchronizationDate, "form", "")
	}
	if r.filterEqExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.expired", r.filterEqExpired, "form", "")
	}
	if r.filterEqProject != nil {
		t := *r.filterEqProject
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.project", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.project", t, "form", "multi")
		}
	}
	if r.filterEqType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.type", r.filterEqType, "form", "")
	}
	if r.filterEqUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.user", r.filterEqUser, "form", "")
	}
	if r.filterEqActive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.active", r.filterEqActive, "form", "")
	}
	if r.filterEqLastLogin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.lastLogin", r.filterEqLastLogin, "form", "")
	}
	if r.filterEqExternalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.externalId", r.filterEqExternalId, "form", "")
	}
	if r.filterEqProjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.projectId", r.filterEqProjectId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFindUsersRequest struct {
	ctx        context.Context
	ApiService *UserAPIService
	term       *string
	pagePage   *int32
	pageSize   *int32
	pageSort   *string
}

func (r ApiFindUsersRequest) Term(term string) ApiFindUsersRequest {
	r.term = &term
	return r
}

// Results page you want to retrieve (0..N)
func (r ApiFindUsersRequest) PagePage(pagePage int32) ApiFindUsersRequest {
	r.pagePage = &pagePage
	return r
}

// Number of records per page
func (r ApiFindUsersRequest) PageSize(pageSize int32) ApiFindUsersRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiFindUsersRequest) PageSort(pageSort string) ApiFindUsersRequest {
	r.pageSort = &pageSort
	return r
}

func (r ApiFindUsersRequest) Execute() (*PageUserResource, *http.Response, error) {
	return r.ApiService.FindUsersExecute(r)
}

/*
FindUsers Find Users

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFindUsersRequest
*/
func (a *UserAPIService) FindUsers(ctx context.Context) ApiFindUsersRequest {
	return ApiFindUsersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PageUserResource
func (a *UserAPIService) FindUsersExecute(r ApiFindUsersRequest) (*PageUserResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageUserResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.FindUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.term == nil {
		return localVarReturnValue, nil, reportError("term is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "term", r.term, "form", "")
	if r.pagePage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.page", r.pagePage, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.sort", r.pageSort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMyselfRequest struct {
	ctx        context.Context
	ApiService *UserAPIService
}

func (r ApiGetMyselfRequest) Execute() (*UserResource, *http.Response, error) {
	return r.ApiService.GetMyselfExecute(r)
}

/*
GetMyself Return information about current logged-in user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetMyselfRequest
*/
func (a *UserAPIService) GetMyself(ctx context.Context) ApiGetMyselfRequest {
	return ApiGetMyselfRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserResource
func (a *UserAPIService) GetMyselfExecute(r ApiGetMyselfRequest) (*UserResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.GetMyself")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMyself1Request struct {
	ctx        context.Context
	ApiService *UserAPIService
}

func (r ApiGetMyself1Request) Execute() (*UserResource, *http.Response, error) {
	return r.ApiService.GetMyself1Execute(r)
}

/*
GetMyself1 Return information about current logged-in user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetMyself1Request
*/
func (a *UserAPIService) GetMyself1(ctx context.Context) ApiGetMyself1Request {
	return ApiGetMyself1Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserResource
func (a *UserAPIService) GetMyself1Execute(r ApiGetMyself1Request) (*UserResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.GetMyself1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserRequest struct {
	ctx        context.Context
	ApiService *UserAPIService
	login      string
}

func (r ApiGetUserRequest) Execute() (*UserResource, *http.Response, error) {
	return r.ApiService.GetUserExecute(r)
}

/*
GetUser Return information about specified user

Only for administrators and profile's owner

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param login
	@return ApiGetUserRequest
*/
func (a *UserAPIService) GetUser(ctx context.Context, login string) ApiGetUserRequest {
	return ApiGetUserRequest{
		ApiService: a,
		ctx:        ctx,
		login:      login,
	}
}

// Execute executes the request
//
//	@return UserResource
func (a *UserAPIService) GetUserExecute(r ApiGetUserRequest) (*UserResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.GetUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{login}"
	localVarPath = strings.Replace(localVarPath, "{"+"login"+"}", url.PathEscape(parameterValueToString(r.login, "login")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserBidInfoRequest struct {
	ctx        context.Context
	ApiService *UserAPIService
	uuid       *string
}

func (r ApiGetUserBidInfoRequest) Uuid(uuid string) ApiGetUserBidInfoRequest {
	r.uuid = &uuid
	return r
}

func (r ApiGetUserBidInfoRequest) Execute() (*UserBidRS, *http.Response, error) {
	return r.ApiService.GetUserBidInfoExecute(r)
}

/*
GetUserBidInfo Get User Bid Info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUserBidInfoRequest
*/
func (a *UserAPIService) GetUserBidInfo(ctx context.Context) ApiGetUserBidInfoRequest {
	return ApiGetUserBidInfoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserBidRS
func (a *UserAPIService) GetUserBidInfoExecute(r ApiGetUserBidInfoRequest) (*UserBidRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserBidRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.GetUserBidInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/registration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uuid == nil {
		return localVarReturnValue, nil, reportError("uuid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "uuid", r.uuid, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserProjectsRequest struct {
	ctx        context.Context
	ApiService *UserAPIService
	userName   string
}

func (r ApiGetUserProjectsRequest) Execute() (*map[string]AssignedProject, *http.Response, error) {
	return r.ApiService.GetUserProjectsExecute(r)
}

/*
GetUserProjects Get User Projects

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userName
	@return ApiGetUserProjectsRequest
*/
func (a *UserAPIService) GetUserProjects(ctx context.Context, userName string) ApiGetUserProjectsRequest {
	return ApiGetUserProjectsRequest{
		ApiService: a,
		ctx:        ctx,
		userName:   userName,
	}
}

// Execute executes the request
//
//	@return map[string]AssignedProject
func (a *UserAPIService) GetUserProjectsExecute(r ApiGetUserProjectsRequest) (*map[string]AssignedProject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *map[string]AssignedProject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.GetUserProjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{userName}/projects"
	localVarPath = strings.Replace(localVarPath, "{"+"userName"+"}", url.PathEscape(parameterValueToString(r.userName, "userName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsersRequest struct {
	ctx                         context.Context
	ApiService                  *UserAPIService
	filterEqFullName            *string
	filterEqUuid                *string
	filterEqEmail               *string
	filterEqId                  *int32
	filterEqRole                *string
	filterEqSynchronizationDate *int32
	filterEqExpired             *bool
	filterEqProject             *[]interface{}
	filterEqType                *string
	filterEqUser                *string
	filterEqActive              *bool
	filterEqLastLogin           *int32
	filterEqExternalId          *string
	filterEqProjectId           *int32
	pagePage                    *int32
	pageSize                    *int32
	pageSort                    *string
}

// Filters by &#39;fullName&#39;
func (r ApiGetUsersRequest) FilterEqFullName(filterEqFullName string) ApiGetUsersRequest {
	r.filterEqFullName = &filterEqFullName
	return r
}

// Filters by &#39;uuid&#39;
func (r ApiGetUsersRequest) FilterEqUuid(filterEqUuid string) ApiGetUsersRequest {
	r.filterEqUuid = &filterEqUuid
	return r
}

// Filters by &#39;email&#39;
func (r ApiGetUsersRequest) FilterEqEmail(filterEqEmail string) ApiGetUsersRequest {
	r.filterEqEmail = &filterEqEmail
	return r
}

// Filters by &#39;id&#39;
func (r ApiGetUsersRequest) FilterEqId(filterEqId int32) ApiGetUsersRequest {
	r.filterEqId = &filterEqId
	return r
}

// Filters by &#39;role&#39;
func (r ApiGetUsersRequest) FilterEqRole(filterEqRole string) ApiGetUsersRequest {
	r.filterEqRole = &filterEqRole
	return r
}

// Filters by &#39;synchronizationDate&#39;
func (r ApiGetUsersRequest) FilterEqSynchronizationDate(filterEqSynchronizationDate int32) ApiGetUsersRequest {
	r.filterEqSynchronizationDate = &filterEqSynchronizationDate
	return r
}

// Filters by &#39;expired&#39;
func (r ApiGetUsersRequest) FilterEqExpired(filterEqExpired bool) ApiGetUsersRequest {
	r.filterEqExpired = &filterEqExpired
	return r
}

// Filters by &#39;project&#39;
func (r ApiGetUsersRequest) FilterEqProject(filterEqProject []interface{}) ApiGetUsersRequest {
	r.filterEqProject = &filterEqProject
	return r
}

// Filters by &#39;type&#39;
func (r ApiGetUsersRequest) FilterEqType(filterEqType string) ApiGetUsersRequest {
	r.filterEqType = &filterEqType
	return r
}

// Filters by &#39;user&#39;
func (r ApiGetUsersRequest) FilterEqUser(filterEqUser string) ApiGetUsersRequest {
	r.filterEqUser = &filterEqUser
	return r
}

// Filters by &#39;active&#39;
func (r ApiGetUsersRequest) FilterEqActive(filterEqActive bool) ApiGetUsersRequest {
	r.filterEqActive = &filterEqActive
	return r
}

// Filters by &#39;lastLogin&#39;
func (r ApiGetUsersRequest) FilterEqLastLogin(filterEqLastLogin int32) ApiGetUsersRequest {
	r.filterEqLastLogin = &filterEqLastLogin
	return r
}

// Filters by &#39;externalId&#39;
func (r ApiGetUsersRequest) FilterEqExternalId(filterEqExternalId string) ApiGetUsersRequest {
	r.filterEqExternalId = &filterEqExternalId
	return r
}

// Filters by &#39;projectId&#39;
func (r ApiGetUsersRequest) FilterEqProjectId(filterEqProjectId int32) ApiGetUsersRequest {
	r.filterEqProjectId = &filterEqProjectId
	return r
}

// Results page you want to retrieve (0..N)
func (r ApiGetUsersRequest) PagePage(pagePage int32) ApiGetUsersRequest {
	r.pagePage = &pagePage
	return r
}

// Number of records per page
func (r ApiGetUsersRequest) PageSize(pageSize int32) ApiGetUsersRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetUsersRequest) PageSort(pageSort string) ApiGetUsersRequest {
	r.pageSort = &pageSort
	return r
}

func (r ApiGetUsersRequest) Execute() (*PageUserResource, *http.Response, error) {
	return r.ApiService.GetUsersExecute(r)
}

/*
GetUsers Return information about all users

Allowable only for users with administrator role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUsersRequest
*/
func (a *UserAPIService) GetUsers(ctx context.Context) ApiGetUsersRequest {
	return ApiGetUsersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PageUserResource
func (a *UserAPIService) GetUsersExecute(r ApiGetUsersRequest) (*PageUserResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageUserResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.GetUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/all"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterEqFullName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.fullName", r.filterEqFullName, "form", "")
	}
	if r.filterEqUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.uuid", r.filterEqUuid, "form", "")
	}
	if r.filterEqEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.email", r.filterEqEmail, "form", "")
	}
	if r.filterEqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.id", r.filterEqId, "form", "")
	}
	if r.filterEqRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.role", r.filterEqRole, "form", "")
	}
	if r.filterEqSynchronizationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.synchronizationDate", r.filterEqSynchronizationDate, "form", "")
	}
	if r.filterEqExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.expired", r.filterEqExpired, "form", "")
	}
	if r.filterEqProject != nil {
		t := *r.filterEqProject
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.project", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.project", t, "form", "multi")
		}
	}
	if r.filterEqType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.type", r.filterEqType, "form", "")
	}
	if r.filterEqUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.user", r.filterEqUser, "form", "")
	}
	if r.filterEqActive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.active", r.filterEqActive, "form", "")
	}
	if r.filterEqLastLogin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.lastLogin", r.filterEqLastLogin, "form", "")
	}
	if r.filterEqExternalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.externalId", r.filterEqExternalId, "form", "")
	}
	if r.filterEqProjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.projectId", r.filterEqProjectId, "form", "")
	}
	if r.pagePage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.page", r.pagePage, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.sort", r.pageSort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsersApiKeysRequest struct {
	ctx        context.Context
	ApiService *UserAPIService
	userId     int64
}

func (r ApiGetUsersApiKeysRequest) Execute() (*ApiKeysRS, *http.Response, error) {
	return r.ApiService.GetUsersApiKeysExecute(r)
}

/*
GetUsersApiKeys Get List of users Api Keys

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId
	@return ApiGetUsersApiKeysRequest
*/
func (a *UserAPIService) GetUsersApiKeys(ctx context.Context, userId int64) ApiGetUsersApiKeysRequest {
	return ApiGetUsersApiKeysRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return ApiKeysRS
func (a *UserAPIService) GetUsersApiKeysExecute(r ApiGetUsersApiKeysRequest) (*ApiKeysRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiKeysRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.GetUsersApiKeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{userId}/api-keys"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIsRestorePasswordBidExistRequest struct {
	ctx        context.Context
	ApiService *UserAPIService
	uuid       string
}

func (r ApiIsRestorePasswordBidExistRequest) Execute() (*YesNoRS, *http.Response, error) {
	return r.ApiService.IsRestorePasswordBidExistExecute(r)
}

/*
IsRestorePasswordBidExist Check if a restore password bid exists

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiIsRestorePasswordBidExistRequest
*/
func (a *UserAPIService) IsRestorePasswordBidExist(ctx context.Context, uuid string) ApiIsRestorePasswordBidExistRequest {
	return ApiIsRestorePasswordBidExistRequest{
		ApiService: a,
		ctx:        ctx,
		uuid:       uuid,
	}
}

// Execute executes the request
//
//	@return YesNoRS
func (a *UserAPIService) IsRestorePasswordBidExistExecute(r ApiIsRestorePasswordBidExistRequest) (*YesNoRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YesNoRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.IsRestorePasswordBidExist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/password/reset/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetPasswordRequest struct {
	ctx             context.Context
	ApiService      *UserAPIService
	resetPasswordRQ *ResetPasswordRQ
}

func (r ApiResetPasswordRequest) ResetPasswordRQ(resetPasswordRQ ResetPasswordRQ) ApiResetPasswordRequest {
	r.resetPasswordRQ = &resetPasswordRQ
	return r
}

func (r ApiResetPasswordRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.ResetPasswordExecute(r)
}

/*
ResetPassword Reset password

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiResetPasswordRequest
*/
func (a *UserAPIService) ResetPassword(ctx context.Context) ApiResetPasswordRequest {
	return ApiResetPasswordRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *UserAPIService) ResetPasswordExecute(r ApiResetPasswordRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.ResetPassword")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/password/reset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resetPasswordRQ == nil {
		return localVarReturnValue, nil, reportError("resetPasswordRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resetPasswordRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestorePasswordRequest struct {
	ctx               context.Context
	ApiService        *UserAPIService
	restorePasswordRQ *RestorePasswordRQ
}

func (r ApiRestorePasswordRequest) RestorePasswordRQ(restorePasswordRQ RestorePasswordRQ) ApiRestorePasswordRequest {
	r.restorePasswordRQ = &restorePasswordRQ
	return r
}

func (r ApiRestorePasswordRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.RestorePasswordExecute(r)
}

/*
RestorePassword Create a restore password request

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRestorePasswordRequest
*/
func (a *UserAPIService) RestorePassword(ctx context.Context) ApiRestorePasswordRequest {
	return ApiRestorePasswordRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *UserAPIService) RestorePasswordExecute(r ApiRestorePasswordRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.RestorePassword")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/password/restore"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restorePasswordRQ == nil {
		return localVarReturnValue, nil, reportError("restorePasswordRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restorePasswordRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateInfoRequest struct {
	ctx        context.Context
	ApiService *UserAPIService
	email      *string
	username   *string
}

func (r ApiValidateInfoRequest) Email(email string) ApiValidateInfoRequest {
	r.email = &email
	return r
}

func (r ApiValidateInfoRequest) Username(username string) ApiValidateInfoRequest {
	r.username = &username
	return r
}

func (r ApiValidateInfoRequest) Execute() (*YesNoRS, *http.Response, error) {
	return r.ApiService.ValidateInfoExecute(r)
}

/*
ValidateInfo Validate Info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidateInfoRequest
*/
func (a *UserAPIService) ValidateInfo(ctx context.Context) ApiValidateInfoRequest {
	return ApiValidateInfoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return YesNoRS
func (a *UserAPIService) ValidateInfoExecute(r ApiValidateInfoRequest) (*YesNoRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *YesNoRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.ValidateInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/registration/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	}
	if r.username != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
