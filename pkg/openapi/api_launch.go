/*
ReportPortal

ReportPortal API documentation

API version: 5.14.4
Contact: support@reportportal.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// LaunchAPIService LaunchAPI service
type LaunchAPIService service

type ApiBulkForceFinishRequest struct {
	ctx                         context.Context
	ApiService                  *LaunchAPIService
	projectName                 string
	bulkRQLongFinishExecutionRQ *BulkRQLongFinishExecutionRQ
}

func (r ApiBulkForceFinishRequest) BulkRQLongFinishExecutionRQ(bulkRQLongFinishExecutionRQ BulkRQLongFinishExecutionRQ) ApiBulkForceFinishRequest {
	r.bulkRQLongFinishExecutionRQ = &bulkRQLongFinishExecutionRQ
	return r
}

func (r ApiBulkForceFinishRequest) Execute() ([]OperationCompletionRS, *http.Response, error) {
	return r.ApiService.BulkForceFinishExecute(r)
}

/*
BulkForceFinish Force finish launch

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiBulkForceFinishRequest
*/
func (a *LaunchAPIService) BulkForceFinish(ctx context.Context, projectName string) ApiBulkForceFinishRequest {
	return ApiBulkForceFinishRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []OperationCompletionRS
func (a *LaunchAPIService) BulkForceFinishExecute(r ApiBulkForceFinishRequest) ([]OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.BulkForceFinish")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkRQLongFinishExecutionRQ == nil {
		return localVarReturnValue, nil, reportError("bulkRQLongFinishExecutionRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkRQLongFinishExecutionRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkUpdateRequest struct {
	ctx              context.Context
	ApiService       *LaunchAPIService
	projectName      string
	bulkInfoUpdateRQ *BulkInfoUpdateRQ
}

func (r ApiBulkUpdateRequest) BulkInfoUpdateRQ(bulkInfoUpdateRQ BulkInfoUpdateRQ) ApiBulkUpdateRequest {
	r.bulkInfoUpdateRQ = &bulkInfoUpdateRQ
	return r
}

func (r ApiBulkUpdateRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.BulkUpdateExecute(r)
}

/*
BulkUpdate Bulk update attributes and description

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiBulkUpdateRequest
*/
func (a *LaunchAPIService) BulkUpdate(ctx context.Context, projectName string) ApiBulkUpdateRequest {
	return ApiBulkUpdateRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *LaunchAPIService) BulkUpdateExecute(r ApiBulkUpdateRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.BulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/info"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkInfoUpdateRQ == nil {
		return localVarReturnValue, nil, reportError("bulkInfoUpdateRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkInfoUpdateRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCompareLaunchesRequest struct {
	ctx         context.Context
	ApiService  *LaunchAPIService
	ids         *[]int64
	projectName string
}

func (r ApiCompareLaunchesRequest) Ids(ids []int64) ApiCompareLaunchesRequest {
	r.ids = &ids
	return r
}

func (r ApiCompareLaunchesRequest) Execute() (*map[string][]ChartStatisticsContent, *http.Response, error) {
	return r.ApiService.CompareLaunchesExecute(r)
}

/*
CompareLaunches Compare launches

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiCompareLaunchesRequest
*/
func (a *LaunchAPIService) CompareLaunches(ctx context.Context, projectName string) ApiCompareLaunchesRequest {
	return ApiCompareLaunchesRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return map[string][]ChartStatisticsContent
func (a *LaunchAPIService) CompareLaunchesExecute(r ApiCompareLaunchesRequest) (*map[string][]ChartStatisticsContent, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *map[string][]ChartStatisticsContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.CompareLaunches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/compare"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	{
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateClustersRequest struct {
	ctx              context.Context
	ApiService       *LaunchAPIService
	projectName      string
	createClustersRQ *CreateClustersRQ
}

func (r ApiCreateClustersRequest) CreateClustersRQ(createClustersRQ CreateClustersRQ) ApiCreateClustersRequest {
	r.createClustersRQ = &createClustersRQ
	return r
}

func (r ApiCreateClustersRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.CreateClustersExecute(r)
}

/*
CreateClusters Create launch clusters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiCreateClustersRequest
*/
func (a *LaunchAPIService) CreateClusters(ctx context.Context, projectName string) ApiCreateClustersRequest {
	return ApiCreateClustersRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *LaunchAPIService) CreateClustersExecute(r ApiCreateClustersRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.CreateClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/cluster"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createClustersRQ == nil {
		return localVarReturnValue, nil, reportError("createClustersRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createClustersRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteLaunchRequest struct {
	ctx         context.Context
	ApiService  *LaunchAPIService
	launchId    int64
	projectName string
}

func (r ApiDeleteLaunchRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.DeleteLaunchExecute(r)
}

/*
DeleteLaunch Delete specified launch by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param launchId
	@param projectName
	@return ApiDeleteLaunchRequest
*/
func (a *LaunchAPIService) DeleteLaunch(ctx context.Context, launchId int64, projectName string) ApiDeleteLaunchRequest {
	return ApiDeleteLaunchRequest{
		ApiService:  a,
		ctx:         ctx,
		launchId:    launchId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *LaunchAPIService) DeleteLaunchExecute(r ApiDeleteLaunchRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.DeleteLaunch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/{launchId}"
	localVarPath = strings.Replace(localVarPath, "{"+"launchId"+"}", url.PathEscape(parameterValueToString(r.launchId, "launchId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteLaunchesRequest struct {
	ctx         context.Context
	ApiService  *LaunchAPIService
	ids         *[]int64
	projectName string
}

func (r ApiDeleteLaunchesRequest) Ids(ids []int64) ApiDeleteLaunchesRequest {
	r.ids = &ids
	return r
}

func (r ApiDeleteLaunchesRequest) Execute() (*DeleteBulkRS, *http.Response, error) {
	return r.ApiService.DeleteLaunchesExecute(r)
}

/*
DeleteLaunches Delete specified launches by ids

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiDeleteLaunchesRequest
*/
func (a *LaunchAPIService) DeleteLaunches(ctx context.Context, projectName string) ApiDeleteLaunchesRequest {
	return ApiDeleteLaunchesRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return DeleteBulkRS
func (a *LaunchAPIService) DeleteLaunchesExecute(r ApiDeleteLaunchesRequest) (*DeleteBulkRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeleteBulkRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.DeleteLaunches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	{
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFinishLaunch1Request struct {
	ctx               context.Context
	ApiService        *LaunchAPIService
	launchId          string
	projectName       string
	finishExecutionRQ *FinishExecutionRQ
}

func (r ApiFinishLaunch1Request) FinishExecutionRQ(finishExecutionRQ FinishExecutionRQ) ApiFinishLaunch1Request {
	r.finishExecutionRQ = &finishExecutionRQ
	return r
}

func (r ApiFinishLaunch1Request) Execute() (*FinishLaunchRS, *http.Response, error) {
	return r.ApiService.FinishLaunch1Execute(r)
}

/*
FinishLaunch1 Finish launch for specified project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param launchId
	@param projectName
	@return ApiFinishLaunch1Request
*/
func (a *LaunchAPIService) FinishLaunch1(ctx context.Context, launchId string, projectName string) ApiFinishLaunch1Request {
	return ApiFinishLaunch1Request{
		ApiService:  a,
		ctx:         ctx,
		launchId:    launchId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return FinishLaunchRS
func (a *LaunchAPIService) FinishLaunch1Execute(r ApiFinishLaunch1Request) (*FinishLaunchRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FinishLaunchRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.FinishLaunch1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/{launchId}/finish"
	localVarPath = strings.Replace(localVarPath, "{"+"launchId"+"}", url.PathEscape(parameterValueToString(r.launchId, "launchId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.finishExecutionRQ == nil {
		return localVarReturnValue, nil, reportError("finishExecutionRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.finishExecutionRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiForceFinishLaunchRequest struct {
	ctx               context.Context
	ApiService        *LaunchAPIService
	launchId          int64
	projectName       string
	finishExecutionRQ *FinishExecutionRQ
}

func (r ApiForceFinishLaunchRequest) FinishExecutionRQ(finishExecutionRQ FinishExecutionRQ) ApiForceFinishLaunchRequest {
	r.finishExecutionRQ = &finishExecutionRQ
	return r
}

func (r ApiForceFinishLaunchRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.ForceFinishLaunchExecute(r)
}

/*
ForceFinishLaunch Force finish launch for specified project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param launchId
	@param projectName
	@return ApiForceFinishLaunchRequest
*/
func (a *LaunchAPIService) ForceFinishLaunch(ctx context.Context, launchId int64, projectName string) ApiForceFinishLaunchRequest {
	return ApiForceFinishLaunchRequest{
		ApiService:  a,
		ctx:         ctx,
		launchId:    launchId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *LaunchAPIService) ForceFinishLaunchExecute(r ApiForceFinishLaunchRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.ForceFinishLaunch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/{launchId}/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"launchId"+"}", url.PathEscape(parameterValueToString(r.launchId, "launchId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.finishExecutionRQ == nil {
		return localVarReturnValue, nil, reportError("finishExecutionRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.finishExecutionRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllLaunchNamesRequest struct {
	ctx           context.Context
	ApiService    *LaunchAPIService
	projectName   string
	filterCntName *string
}

func (r ApiGetAllLaunchNamesRequest) FilterCntName(filterCntName string) ApiGetAllLaunchNamesRequest {
	r.filterCntName = &filterCntName
	return r
}

func (r ApiGetAllLaunchNamesRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetAllLaunchNamesExecute(r)
}

/*
GetAllLaunchNames Get launch names of project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetAllLaunchNamesRequest
*/
func (a *LaunchAPIService) GetAllLaunchNames(ctx context.Context, projectName string) ApiGetAllLaunchNamesRequest {
	return ApiGetAllLaunchNamesRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []string
func (a *LaunchAPIService) GetAllLaunchNamesExecute(r ApiGetAllLaunchNamesRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.GetAllLaunchNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/names"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterCntName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.cnt.name", r.filterCntName, "form", "")
	} else {
		var defaultValue string = ""
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.cnt.name", defaultValue, "form", "")
		r.filterCntName = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllOwnersRequest struct {
	ctx           context.Context
	ApiService    *LaunchAPIService
	filterCntUser *string
	projectName   string
	mode          *string
}

func (r ApiGetAllOwnersRequest) FilterCntUser(filterCntUser string) ApiGetAllOwnersRequest {
	r.filterCntUser = &filterCntUser
	return r
}

func (r ApiGetAllOwnersRequest) Mode(mode string) ApiGetAllOwnersRequest {
	r.mode = &mode
	return r
}

func (r ApiGetAllOwnersRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetAllOwnersExecute(r)
}

/*
GetAllOwners Get all unique owners of project launches

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetAllOwnersRequest
*/
func (a *LaunchAPIService) GetAllOwners(ctx context.Context, projectName string) ApiGetAllOwnersRequest {
	return ApiGetAllOwnersRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []string
func (a *LaunchAPIService) GetAllOwnersExecute(r ApiGetAllOwnersRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.GetAllOwners")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/owners"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.filterCntUser == nil {
		return localVarReturnValue, nil, reportError("filterCntUser is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "filter.cnt.user", r.filterCntUser, "form", "")
	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "form", "")
	} else {
		var defaultValue string = "DEFAULT"
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", defaultValue, "form", "")
		r.mode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAttributeKeysRequest struct {
	ctx                   context.Context
	ApiService            *LaunchAPIService
	filterCntAttributeKey *string
	projectName           string
}

func (r ApiGetAttributeKeysRequest) FilterCntAttributeKey(filterCntAttributeKey string) ApiGetAttributeKeysRequest {
	r.filterCntAttributeKey = &filterCntAttributeKey
	return r
}

func (r ApiGetAttributeKeysRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetAttributeKeysExecute(r)
}

/*
GetAttributeKeys Get all unique attribute keys of project launches

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetAttributeKeysRequest
*/
func (a *LaunchAPIService) GetAttributeKeys(ctx context.Context, projectName string) ApiGetAttributeKeysRequest {
	return ApiGetAttributeKeysRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []string
func (a *LaunchAPIService) GetAttributeKeysExecute(r ApiGetAttributeKeysRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.GetAttributeKeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/attribute/keys"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.filterCntAttributeKey == nil {
		return localVarReturnValue, nil, reportError("filterCntAttributeKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "filter.cnt.attributeKey", r.filterCntAttributeKey, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAttributeValuesRequest struct {
	ctx                     context.Context
	ApiService              *LaunchAPIService
	filterCntAttributeValue *string
	projectName             string
	filterEqAttributeKey    *string
}

func (r ApiGetAttributeValuesRequest) FilterCntAttributeValue(filterCntAttributeValue string) ApiGetAttributeValuesRequest {
	r.filterCntAttributeValue = &filterCntAttributeValue
	return r
}

func (r ApiGetAttributeValuesRequest) FilterEqAttributeKey(filterEqAttributeKey string) ApiGetAttributeValuesRequest {
	r.filterEqAttributeKey = &filterEqAttributeKey
	return r
}

func (r ApiGetAttributeValuesRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetAttributeValuesExecute(r)
}

/*
GetAttributeValues Get all unique attribute values of project launches

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetAttributeValuesRequest
*/
func (a *LaunchAPIService) GetAttributeValues(ctx context.Context, projectName string) ApiGetAttributeValuesRequest {
	return ApiGetAttributeValuesRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []string
func (a *LaunchAPIService) GetAttributeValuesExecute(r ApiGetAttributeValuesRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.GetAttributeValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/attribute/values"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.filterCntAttributeValue == nil {
		return localVarReturnValue, nil, reportError("filterCntAttributeValue is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "filter.cnt.attributeValue", r.filterCntAttributeValue, "form", "")
	if r.filterEqAttributeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeKey", r.filterEqAttributeKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClustersRequest struct {
	ctx         context.Context
	ApiService  *LaunchAPIService
	launchId    string
	projectName string
	pagePage    *int32
	pageSize    *int32
	pageSort    *string
}

// Results page you want to retrieve (0..N)
func (r ApiGetClustersRequest) PagePage(pagePage int32) ApiGetClustersRequest {
	r.pagePage = &pagePage
	return r
}

// Number of records per page
func (r ApiGetClustersRequest) PageSize(pageSize int32) ApiGetClustersRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetClustersRequest) PageSort(pageSort string) ApiGetClustersRequest {
	r.pageSort = &pageSort
	return r
}

func (r ApiGetClustersRequest) Execute() (*PageClusterInfoResource, *http.Response, error) {
	return r.ApiService.GetClustersExecute(r)
}

/*
GetClusters Get all index clusters of the launch

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param launchId
	@param projectName
	@return ApiGetClustersRequest
*/
func (a *LaunchAPIService) GetClusters(ctx context.Context, launchId string, projectName string) ApiGetClustersRequest {
	return ApiGetClustersRequest{
		ApiService:  a,
		ctx:         ctx,
		launchId:    launchId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return PageClusterInfoResource
func (a *LaunchAPIService) GetClustersExecute(r ApiGetClustersRequest) (*PageClusterInfoResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageClusterInfoResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.GetClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/cluster/{launchId}"
	localVarPath = strings.Replace(localVarPath, "{"+"launchId"+"}", url.PathEscape(parameterValueToString(r.launchId, "launchId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pagePage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.page", r.pagePage, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.sort", r.pageSort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDebugLaunchesRequest struct {
	ctx                                         context.Context
	ApiService                                  *LaunchAPIService
	projectName                                 string
	filterEqStatisticsdefectsproductBugpb001    *int32
	filterEqUuid                                *string
	filterEqId                                  *int32
	filterEqStatisticsdefectsautomationBugab001 *int32
	filterEqAttributeKey                        *string
	filterEqUserId                              *int32
	filterEqStatus                              *string
	filterEqStartTime                           *string
	filterEqMode                                *string
	filterEqHasRetries                          *bool
	filterEqNumber                              *int32
	filterEqLastModified                        *string
	filterEqProjectId                           *int32
	filterHasCompositeAttribute                 *string
	filterEqEndTime                             *string
	filterEqStatisticsexecutionspassed          *int32
	filterEqName                                *string
	filterEqStatisticsdefectsnoDefectnd001      *int32
	filterEqDescription                         *string
	filterEqUser                                *string
	filterEqStatisticsexecutionsfailed          *int32
	filterEqStatisticsdefectssystemIssuesi001   *int32
	filterEqAttributeValue                      *string
	filterEqStatisticsexecutionstotal           *int32
	filterEqStatisticsexecutionsskipped         *int32
	filterEqStatisticsdefectstoInvestigateti001 *int32
	pagePage                                    *int32
	pageSize                                    *int32
	pageSort                                    *string
}

// Filters by &#39;statistics$defects$product_bug$pb001&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqStatisticsdefectsproductBugpb001(filterEqStatisticsdefectsproductBugpb001 int32) ApiGetDebugLaunchesRequest {
	r.filterEqStatisticsdefectsproductBugpb001 = &filterEqStatisticsdefectsproductBugpb001
	return r
}

// Filters by &#39;uuid&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqUuid(filterEqUuid string) ApiGetDebugLaunchesRequest {
	r.filterEqUuid = &filterEqUuid
	return r
}

// Filters by &#39;id&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqId(filterEqId int32) ApiGetDebugLaunchesRequest {
	r.filterEqId = &filterEqId
	return r
}

// Filters by &#39;statistics$defects$automation_bug$ab001&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqStatisticsdefectsautomationBugab001(filterEqStatisticsdefectsautomationBugab001 int32) ApiGetDebugLaunchesRequest {
	r.filterEqStatisticsdefectsautomationBugab001 = &filterEqStatisticsdefectsautomationBugab001
	return r
}

// Filters by &#39;attributeKey&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqAttributeKey(filterEqAttributeKey string) ApiGetDebugLaunchesRequest {
	r.filterEqAttributeKey = &filterEqAttributeKey
	return r
}

// Filters by &#39;userId&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqUserId(filterEqUserId int32) ApiGetDebugLaunchesRequest {
	r.filterEqUserId = &filterEqUserId
	return r
}

// Filters by &#39;status&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqStatus(filterEqStatus string) ApiGetDebugLaunchesRequest {
	r.filterEqStatus = &filterEqStatus
	return r
}

// Filters by &#39;startTime&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqStartTime(filterEqStartTime string) ApiGetDebugLaunchesRequest {
	r.filterEqStartTime = &filterEqStartTime
	return r
}

// Filters by &#39;mode&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqMode(filterEqMode string) ApiGetDebugLaunchesRequest {
	r.filterEqMode = &filterEqMode
	return r
}

// Filters by &#39;hasRetries&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqHasRetries(filterEqHasRetries bool) ApiGetDebugLaunchesRequest {
	r.filterEqHasRetries = &filterEqHasRetries
	return r
}

// Filters by &#39;number&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqNumber(filterEqNumber int32) ApiGetDebugLaunchesRequest {
	r.filterEqNumber = &filterEqNumber
	return r
}

// Filters by &#39;lastModified&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqLastModified(filterEqLastModified string) ApiGetDebugLaunchesRequest {
	r.filterEqLastModified = &filterEqLastModified
	return r
}

// Filters by &#39;projectId&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqProjectId(filterEqProjectId int32) ApiGetDebugLaunchesRequest {
	r.filterEqProjectId = &filterEqProjectId
	return r
}

// Filters by &#39;compositeAttribute&#39;
func (r ApiGetDebugLaunchesRequest) FilterHasCompositeAttribute(filterHasCompositeAttribute string) ApiGetDebugLaunchesRequest {
	r.filterHasCompositeAttribute = &filterHasCompositeAttribute
	return r
}

// Filters by &#39;endTime&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqEndTime(filterEqEndTime string) ApiGetDebugLaunchesRequest {
	r.filterEqEndTime = &filterEqEndTime
	return r
}

// Filters by &#39;statistics$executions$passed&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqStatisticsexecutionspassed(filterEqStatisticsexecutionspassed int32) ApiGetDebugLaunchesRequest {
	r.filterEqStatisticsexecutionspassed = &filterEqStatisticsexecutionspassed
	return r
}

// Filters by &#39;name&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqName(filterEqName string) ApiGetDebugLaunchesRequest {
	r.filterEqName = &filterEqName
	return r
}

// Filters by &#39;statistics$defects$no_defect$nd001&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqStatisticsdefectsnoDefectnd001(filterEqStatisticsdefectsnoDefectnd001 int32) ApiGetDebugLaunchesRequest {
	r.filterEqStatisticsdefectsnoDefectnd001 = &filterEqStatisticsdefectsnoDefectnd001
	return r
}

// Filters by &#39;description&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqDescription(filterEqDescription string) ApiGetDebugLaunchesRequest {
	r.filterEqDescription = &filterEqDescription
	return r
}

// Filters by &#39;user&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqUser(filterEqUser string) ApiGetDebugLaunchesRequest {
	r.filterEqUser = &filterEqUser
	return r
}

// Filters by &#39;statistics$executions$failed&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqStatisticsexecutionsfailed(filterEqStatisticsexecutionsfailed int32) ApiGetDebugLaunchesRequest {
	r.filterEqStatisticsexecutionsfailed = &filterEqStatisticsexecutionsfailed
	return r
}

// Filters by &#39;statistics$defects$system_issue$si001&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqStatisticsdefectssystemIssuesi001(filterEqStatisticsdefectssystemIssuesi001 int32) ApiGetDebugLaunchesRequest {
	r.filterEqStatisticsdefectssystemIssuesi001 = &filterEqStatisticsdefectssystemIssuesi001
	return r
}

// Filters by &#39;attributeValue&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqAttributeValue(filterEqAttributeValue string) ApiGetDebugLaunchesRequest {
	r.filterEqAttributeValue = &filterEqAttributeValue
	return r
}

// Filters by &#39;statistics$executions$total&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqStatisticsexecutionstotal(filterEqStatisticsexecutionstotal int32) ApiGetDebugLaunchesRequest {
	r.filterEqStatisticsexecutionstotal = &filterEqStatisticsexecutionstotal
	return r
}

// Filters by &#39;statistics$executions$skipped&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqStatisticsexecutionsskipped(filterEqStatisticsexecutionsskipped int32) ApiGetDebugLaunchesRequest {
	r.filterEqStatisticsexecutionsskipped = &filterEqStatisticsexecutionsskipped
	return r
}

// Filters by &#39;statistics$defects$to_investigate$ti001&#39;
func (r ApiGetDebugLaunchesRequest) FilterEqStatisticsdefectstoInvestigateti001(filterEqStatisticsdefectstoInvestigateti001 int32) ApiGetDebugLaunchesRequest {
	r.filterEqStatisticsdefectstoInvestigateti001 = &filterEqStatisticsdefectstoInvestigateti001
	return r
}

// Results page you want to retrieve (0..N)
func (r ApiGetDebugLaunchesRequest) PagePage(pagePage int32) ApiGetDebugLaunchesRequest {
	r.pagePage = &pagePage
	return r
}

// Number of records per page
func (r ApiGetDebugLaunchesRequest) PageSize(pageSize int32) ApiGetDebugLaunchesRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetDebugLaunchesRequest) PageSort(pageSort string) ApiGetDebugLaunchesRequest {
	r.pageSort = &pageSort
	return r
}

func (r ApiGetDebugLaunchesRequest) Execute() (*PageLaunchResource, *http.Response, error) {
	return r.ApiService.GetDebugLaunchesExecute(r)
}

/*
GetDebugLaunches Get launches of specified project from DEBUG mode

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetDebugLaunchesRequest
*/
func (a *LaunchAPIService) GetDebugLaunches(ctx context.Context, projectName string) ApiGetDebugLaunchesRequest {
	return ApiGetDebugLaunchesRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return PageLaunchResource
func (a *LaunchAPIService) GetDebugLaunchesExecute(r ApiGetDebugLaunchesRequest) (*PageLaunchResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageLaunchResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.GetDebugLaunches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/mode"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterEqStatisticsdefectsproductBugpb001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$product_bug$pb001", r.filterEqStatisticsdefectsproductBugpb001, "form", "")
	}
	if r.filterEqUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.uuid", r.filterEqUuid, "form", "")
	}
	if r.filterEqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.id", r.filterEqId, "form", "")
	}
	if r.filterEqStatisticsdefectsautomationBugab001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$automation_bug$ab001", r.filterEqStatisticsdefectsautomationBugab001, "form", "")
	}
	if r.filterEqAttributeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeKey", r.filterEqAttributeKey, "form", "")
	}
	if r.filterEqUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.userId", r.filterEqUserId, "form", "")
	}
	if r.filterEqStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.status", r.filterEqStatus, "form", "")
	}
	if r.filterEqStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.startTime", r.filterEqStartTime, "form", "")
	}
	if r.filterEqMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.mode", r.filterEqMode, "form", "")
	}
	if r.filterEqHasRetries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.hasRetries", r.filterEqHasRetries, "form", "")
	}
	if r.filterEqNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.number", r.filterEqNumber, "form", "")
	}
	if r.filterEqLastModified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.lastModified", r.filterEqLastModified, "form", "")
	}
	if r.filterEqProjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.projectId", r.filterEqProjectId, "form", "")
	}
	if r.filterHasCompositeAttribute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.has.compositeAttribute", r.filterHasCompositeAttribute, "form", "")
	}
	if r.filterEqEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.endTime", r.filterEqEndTime, "form", "")
	}
	if r.filterEqStatisticsexecutionspassed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$passed", r.filterEqStatisticsexecutionspassed, "form", "")
	}
	if r.filterEqName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.name", r.filterEqName, "form", "")
	}
	if r.filterEqStatisticsdefectsnoDefectnd001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$no_defect$nd001", r.filterEqStatisticsdefectsnoDefectnd001, "form", "")
	}
	if r.filterEqDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.description", r.filterEqDescription, "form", "")
	}
	if r.filterEqUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.user", r.filterEqUser, "form", "")
	}
	if r.filterEqStatisticsexecutionsfailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$failed", r.filterEqStatisticsexecutionsfailed, "form", "")
	}
	if r.filterEqStatisticsdefectssystemIssuesi001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$system_issue$si001", r.filterEqStatisticsdefectssystemIssuesi001, "form", "")
	}
	if r.filterEqAttributeValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeValue", r.filterEqAttributeValue, "form", "")
	}
	if r.filterEqStatisticsexecutionstotal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$total", r.filterEqStatisticsexecutionstotal, "form", "")
	}
	if r.filterEqStatisticsexecutionsskipped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$skipped", r.filterEqStatisticsexecutionsskipped, "form", "")
	}
	if r.filterEqStatisticsdefectstoInvestigateti001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$to_investigate$ti001", r.filterEqStatisticsdefectstoInvestigateti001, "form", "")
	}
	if r.pagePage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.page", r.pagePage, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.sort", r.pageSort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLatestLaunchesRequest struct {
	ctx                                         context.Context
	ApiService                                  *LaunchAPIService
	projectName                                 string
	filterEqStatisticsdefectsproductBugpb001    *int32
	filterEqUuid                                *string
	filterEqId                                  *int32
	filterEqStatisticsdefectsautomationBugab001 *int32
	filterEqAttributeKey                        *string
	filterEqUserId                              *int32
	filterEqStatus                              *string
	filterEqStartTime                           *string
	filterEqMode                                *string
	filterEqHasRetries                          *bool
	filterEqNumber                              *int32
	filterEqLastModified                        *string
	filterEqProjectId                           *int32
	filterHasCompositeAttribute                 *string
	filterEqEndTime                             *string
	filterEqStatisticsexecutionspassed          *int32
	filterEqName                                *string
	filterEqStatisticsdefectsnoDefectnd001      *int32
	filterEqDescription                         *string
	filterEqUser                                *string
	filterEqStatisticsexecutionsfailed          *int32
	filterEqStatisticsdefectssystemIssuesi001   *int32
	filterEqAttributeValue                      *string
	filterEqStatisticsexecutionstotal           *int32
	filterEqStatisticsexecutionsskipped         *int32
	filterEqStatisticsdefectstoInvestigateti001 *int32
	pagePage                                    *int32
	pageSize                                    *int32
	pageSort                                    *string
}

// Filters by &#39;statistics$defects$product_bug$pb001&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqStatisticsdefectsproductBugpb001(filterEqStatisticsdefectsproductBugpb001 int32) ApiGetLatestLaunchesRequest {
	r.filterEqStatisticsdefectsproductBugpb001 = &filterEqStatisticsdefectsproductBugpb001
	return r
}

// Filters by &#39;uuid&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqUuid(filterEqUuid string) ApiGetLatestLaunchesRequest {
	r.filterEqUuid = &filterEqUuid
	return r
}

// Filters by &#39;id&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqId(filterEqId int32) ApiGetLatestLaunchesRequest {
	r.filterEqId = &filterEqId
	return r
}

// Filters by &#39;statistics$defects$automation_bug$ab001&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqStatisticsdefectsautomationBugab001(filterEqStatisticsdefectsautomationBugab001 int32) ApiGetLatestLaunchesRequest {
	r.filterEqStatisticsdefectsautomationBugab001 = &filterEqStatisticsdefectsautomationBugab001
	return r
}

// Filters by &#39;attributeKey&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqAttributeKey(filterEqAttributeKey string) ApiGetLatestLaunchesRequest {
	r.filterEqAttributeKey = &filterEqAttributeKey
	return r
}

// Filters by &#39;userId&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqUserId(filterEqUserId int32) ApiGetLatestLaunchesRequest {
	r.filterEqUserId = &filterEqUserId
	return r
}

// Filters by &#39;status&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqStatus(filterEqStatus string) ApiGetLatestLaunchesRequest {
	r.filterEqStatus = &filterEqStatus
	return r
}

// Filters by &#39;startTime&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqStartTime(filterEqStartTime string) ApiGetLatestLaunchesRequest {
	r.filterEqStartTime = &filterEqStartTime
	return r
}

// Filters by &#39;mode&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqMode(filterEqMode string) ApiGetLatestLaunchesRequest {
	r.filterEqMode = &filterEqMode
	return r
}

// Filters by &#39;hasRetries&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqHasRetries(filterEqHasRetries bool) ApiGetLatestLaunchesRequest {
	r.filterEqHasRetries = &filterEqHasRetries
	return r
}

// Filters by &#39;number&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqNumber(filterEqNumber int32) ApiGetLatestLaunchesRequest {
	r.filterEqNumber = &filterEqNumber
	return r
}

// Filters by &#39;lastModified&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqLastModified(filterEqLastModified string) ApiGetLatestLaunchesRequest {
	r.filterEqLastModified = &filterEqLastModified
	return r
}

// Filters by &#39;projectId&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqProjectId(filterEqProjectId int32) ApiGetLatestLaunchesRequest {
	r.filterEqProjectId = &filterEqProjectId
	return r
}

// Filters by &#39;compositeAttribute&#39;
func (r ApiGetLatestLaunchesRequest) FilterHasCompositeAttribute(filterHasCompositeAttribute string) ApiGetLatestLaunchesRequest {
	r.filterHasCompositeAttribute = &filterHasCompositeAttribute
	return r
}

// Filters by &#39;endTime&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqEndTime(filterEqEndTime string) ApiGetLatestLaunchesRequest {
	r.filterEqEndTime = &filterEqEndTime
	return r
}

// Filters by &#39;statistics$executions$passed&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqStatisticsexecutionspassed(filterEqStatisticsexecutionspassed int32) ApiGetLatestLaunchesRequest {
	r.filterEqStatisticsexecutionspassed = &filterEqStatisticsexecutionspassed
	return r
}

// Filters by &#39;name&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqName(filterEqName string) ApiGetLatestLaunchesRequest {
	r.filterEqName = &filterEqName
	return r
}

// Filters by &#39;statistics$defects$no_defect$nd001&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqStatisticsdefectsnoDefectnd001(filterEqStatisticsdefectsnoDefectnd001 int32) ApiGetLatestLaunchesRequest {
	r.filterEqStatisticsdefectsnoDefectnd001 = &filterEqStatisticsdefectsnoDefectnd001
	return r
}

// Filters by &#39;description&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqDescription(filterEqDescription string) ApiGetLatestLaunchesRequest {
	r.filterEqDescription = &filterEqDescription
	return r
}

// Filters by &#39;user&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqUser(filterEqUser string) ApiGetLatestLaunchesRequest {
	r.filterEqUser = &filterEqUser
	return r
}

// Filters by &#39;statistics$executions$failed&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqStatisticsexecutionsfailed(filterEqStatisticsexecutionsfailed int32) ApiGetLatestLaunchesRequest {
	r.filterEqStatisticsexecutionsfailed = &filterEqStatisticsexecutionsfailed
	return r
}

// Filters by &#39;statistics$defects$system_issue$si001&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqStatisticsdefectssystemIssuesi001(filterEqStatisticsdefectssystemIssuesi001 int32) ApiGetLatestLaunchesRequest {
	r.filterEqStatisticsdefectssystemIssuesi001 = &filterEqStatisticsdefectssystemIssuesi001
	return r
}

// Filters by &#39;attributeValue&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqAttributeValue(filterEqAttributeValue string) ApiGetLatestLaunchesRequest {
	r.filterEqAttributeValue = &filterEqAttributeValue
	return r
}

// Filters by &#39;statistics$executions$total&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqStatisticsexecutionstotal(filterEqStatisticsexecutionstotal int32) ApiGetLatestLaunchesRequest {
	r.filterEqStatisticsexecutionstotal = &filterEqStatisticsexecutionstotal
	return r
}

// Filters by &#39;statistics$executions$skipped&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqStatisticsexecutionsskipped(filterEqStatisticsexecutionsskipped int32) ApiGetLatestLaunchesRequest {
	r.filterEqStatisticsexecutionsskipped = &filterEqStatisticsexecutionsskipped
	return r
}

// Filters by &#39;statistics$defects$to_investigate$ti001&#39;
func (r ApiGetLatestLaunchesRequest) FilterEqStatisticsdefectstoInvestigateti001(filterEqStatisticsdefectstoInvestigateti001 int32) ApiGetLatestLaunchesRequest {
	r.filterEqStatisticsdefectstoInvestigateti001 = &filterEqStatisticsdefectstoInvestigateti001
	return r
}

// Results page you want to retrieve (0..N)
func (r ApiGetLatestLaunchesRequest) PagePage(pagePage int32) ApiGetLatestLaunchesRequest {
	r.pagePage = &pagePage
	return r
}

// Number of records per page
func (r ApiGetLatestLaunchesRequest) PageSize(pageSize int32) ApiGetLatestLaunchesRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetLatestLaunchesRequest) PageSort(pageSort string) ApiGetLatestLaunchesRequest {
	r.pageSort = &pageSort
	return r
}

func (r ApiGetLatestLaunchesRequest) Execute() (*PageLaunchResource, *http.Response, error) {
	return r.ApiService.GetLatestLaunchesExecute(r)
}

/*
GetLatestLaunches Get list of latest project launches by filter

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetLatestLaunchesRequest
*/
func (a *LaunchAPIService) GetLatestLaunches(ctx context.Context, projectName string) ApiGetLatestLaunchesRequest {
	return ApiGetLatestLaunchesRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return PageLaunchResource
func (a *LaunchAPIService) GetLatestLaunchesExecute(r ApiGetLatestLaunchesRequest) (*PageLaunchResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageLaunchResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.GetLatestLaunches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterEqStatisticsdefectsproductBugpb001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$product_bug$pb001", r.filterEqStatisticsdefectsproductBugpb001, "form", "")
	}
	if r.filterEqUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.uuid", r.filterEqUuid, "form", "")
	}
	if r.filterEqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.id", r.filterEqId, "form", "")
	}
	if r.filterEqStatisticsdefectsautomationBugab001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$automation_bug$ab001", r.filterEqStatisticsdefectsautomationBugab001, "form", "")
	}
	if r.filterEqAttributeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeKey", r.filterEqAttributeKey, "form", "")
	}
	if r.filterEqUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.userId", r.filterEqUserId, "form", "")
	}
	if r.filterEqStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.status", r.filterEqStatus, "form", "")
	}
	if r.filterEqStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.startTime", r.filterEqStartTime, "form", "")
	}
	if r.filterEqMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.mode", r.filterEqMode, "form", "")
	}
	if r.filterEqHasRetries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.hasRetries", r.filterEqHasRetries, "form", "")
	}
	if r.filterEqNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.number", r.filterEqNumber, "form", "")
	}
	if r.filterEqLastModified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.lastModified", r.filterEqLastModified, "form", "")
	}
	if r.filterEqProjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.projectId", r.filterEqProjectId, "form", "")
	}
	if r.filterHasCompositeAttribute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.has.compositeAttribute", r.filterHasCompositeAttribute, "form", "")
	}
	if r.filterEqEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.endTime", r.filterEqEndTime, "form", "")
	}
	if r.filterEqStatisticsexecutionspassed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$passed", r.filterEqStatisticsexecutionspassed, "form", "")
	}
	if r.filterEqName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.name", r.filterEqName, "form", "")
	}
	if r.filterEqStatisticsdefectsnoDefectnd001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$no_defect$nd001", r.filterEqStatisticsdefectsnoDefectnd001, "form", "")
	}
	if r.filterEqDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.description", r.filterEqDescription, "form", "")
	}
	if r.filterEqUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.user", r.filterEqUser, "form", "")
	}
	if r.filterEqStatisticsexecutionsfailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$failed", r.filterEqStatisticsexecutionsfailed, "form", "")
	}
	if r.filterEqStatisticsdefectssystemIssuesi001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$system_issue$si001", r.filterEqStatisticsdefectssystemIssuesi001, "form", "")
	}
	if r.filterEqAttributeValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeValue", r.filterEqAttributeValue, "form", "")
	}
	if r.filterEqStatisticsexecutionstotal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$total", r.filterEqStatisticsexecutionstotal, "form", "")
	}
	if r.filterEqStatisticsexecutionsskipped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$skipped", r.filterEqStatisticsexecutionsskipped, "form", "")
	}
	if r.filterEqStatisticsdefectstoInvestigateti001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$to_investigate$ti001", r.filterEqStatisticsdefectstoInvestigateti001, "form", "")
	}
	if r.pagePage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.page", r.pagePage, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.sort", r.pageSort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLaunchRequest struct {
	ctx         context.Context
	ApiService  *LaunchAPIService
	launchId    string
	projectName string
}

func (r ApiGetLaunchRequest) Execute() (*LaunchResource, *http.Response, error) {
	return r.ApiService.GetLaunchExecute(r)
}

/*
GetLaunch Get specified launch by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param launchId
	@param projectName
	@return ApiGetLaunchRequest
*/
func (a *LaunchAPIService) GetLaunch(ctx context.Context, launchId string, projectName string) ApiGetLaunchRequest {
	return ApiGetLaunchRequest{
		ApiService:  a,
		ctx:         ctx,
		launchId:    launchId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return LaunchResource
func (a *LaunchAPIService) GetLaunchExecute(r ApiGetLaunchRequest) (*LaunchResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LaunchResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.GetLaunch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/{launchId}"
	localVarPath = strings.Replace(localVarPath, "{"+"launchId"+"}", url.PathEscape(parameterValueToString(r.launchId, "launchId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLaunchByUuidOldTimestampRequest struct {
	ctx         context.Context
	ApiService  *LaunchAPIService
	launchId    string
	projectName string
}

func (r ApiGetLaunchByUuidOldTimestampRequest) Execute() (*LaunchResourceOld, *http.Response, error) {
	return r.ApiService.GetLaunchByUuidOldTimestampExecute(r)
}

/*
GetLaunchByUuidOldTimestamp Get specified launch by UUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param launchId
	@param projectName
	@return ApiGetLaunchByUuidOldTimestampRequest
*/
func (a *LaunchAPIService) GetLaunchByUuidOldTimestamp(ctx context.Context, launchId string, projectName string) ApiGetLaunchByUuidOldTimestampRequest {
	return ApiGetLaunchByUuidOldTimestampRequest{
		ApiService:  a,
		ctx:         ctx,
		launchId:    launchId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return LaunchResourceOld
func (a *LaunchAPIService) GetLaunchByUuidOldTimestampExecute(r ApiGetLaunchByUuidOldTimestampRequest) (*LaunchResourceOld, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LaunchResourceOld
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.GetLaunchByUuidOldTimestamp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/uuid/{launchId}"
	localVarPath = strings.Replace(localVarPath, "{"+"launchId"+"}", url.PathEscape(parameterValueToString(r.launchId, "launchId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x.reportportal.launch.v2+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLaunchReportRequest struct {
	ctx                context.Context
	ApiService         *LaunchAPIService
	launchId           int64
	projectName        string
	includeAttachments *bool
	view               *string
}

func (r ApiGetLaunchReportRequest) IncludeAttachments(includeAttachments bool) ApiGetLaunchReportRequest {
	r.includeAttachments = &includeAttachments
	return r
}

func (r ApiGetLaunchReportRequest) View(view string) ApiGetLaunchReportRequest {
	r.view = &view
	return r
}

func (r ApiGetLaunchReportRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetLaunchReportExecute(r)
}

/*
GetLaunchReport Export specified launch

Only following formats are supported: pdf (by default), xls, html.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param launchId
	@param projectName
	@return ApiGetLaunchReportRequest
*/
func (a *LaunchAPIService) GetLaunchReport(ctx context.Context, launchId int64, projectName string) ApiGetLaunchReportRequest {
	return ApiGetLaunchReportRequest{
		ApiService:  a,
		ctx:         ctx,
		launchId:    launchId,
		projectName: projectName,
	}
}

// Execute executes the request
func (a *LaunchAPIService) GetLaunchReportExecute(r ApiGetLaunchReportRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.GetLaunchReport")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/{launchId}/report"
	localVarPath = strings.Replace(localVarPath, "{"+"launchId"+"}", url.PathEscape(parameterValueToString(r.launchId, "launchId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeAttachments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAttachments", r.includeAttachments, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAttachments", defaultValue, "form", "")
		r.includeAttachments = &defaultValue
	}
	if r.view != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view", r.view, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetProjectLaunchesRequest struct {
	ctx                                         context.Context
	ApiService                                  *LaunchAPIService
	projectName                                 string
	filterEqStatisticsdefectsproductBugpb001    *int32
	filterEqUuid                                *string
	filterEqId                                  *int32
	filterEqStatisticsdefectsautomationBugab001 *int32
	filterEqAttributeKey                        *string
	filterEqUserId                              *int32
	filterEqStatus                              *string
	filterEqStartTime                           *string
	filterEqMode                                *string
	filterEqHasRetries                          *bool
	filterEqNumber                              *int32
	filterEqLastModified                        *string
	filterEqProjectId                           *int32
	filterHasCompositeAttribute                 *string
	filterEqEndTime                             *string
	filterEqStatisticsexecutionspassed          *int32
	filterEqName                                *string
	filterEqStatisticsdefectsnoDefectnd001      *int32
	filterEqDescription                         *string
	filterEqUser                                *string
	filterEqStatisticsexecutionsfailed          *int32
	filterEqStatisticsdefectssystemIssuesi001   *int32
	filterEqAttributeValue                      *string
	filterEqStatisticsexecutionstotal           *int32
	filterEqStatisticsexecutionsskipped         *int32
	filterEqStatisticsdefectstoInvestigateti001 *int32
	pagePage                                    *int32
	pageSize                                    *int32
	pageSort                                    *string
}

// Filters by &#39;statistics$defects$product_bug$pb001&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqStatisticsdefectsproductBugpb001(filterEqStatisticsdefectsproductBugpb001 int32) ApiGetProjectLaunchesRequest {
	r.filterEqStatisticsdefectsproductBugpb001 = &filterEqStatisticsdefectsproductBugpb001
	return r
}

// Filters by &#39;uuid&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqUuid(filterEqUuid string) ApiGetProjectLaunchesRequest {
	r.filterEqUuid = &filterEqUuid
	return r
}

// Filters by &#39;id&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqId(filterEqId int32) ApiGetProjectLaunchesRequest {
	r.filterEqId = &filterEqId
	return r
}

// Filters by &#39;statistics$defects$automation_bug$ab001&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqStatisticsdefectsautomationBugab001(filterEqStatisticsdefectsautomationBugab001 int32) ApiGetProjectLaunchesRequest {
	r.filterEqStatisticsdefectsautomationBugab001 = &filterEqStatisticsdefectsautomationBugab001
	return r
}

// Filters by &#39;attributeKey&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqAttributeKey(filterEqAttributeKey string) ApiGetProjectLaunchesRequest {
	r.filterEqAttributeKey = &filterEqAttributeKey
	return r
}

// Filters by &#39;userId&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqUserId(filterEqUserId int32) ApiGetProjectLaunchesRequest {
	r.filterEqUserId = &filterEqUserId
	return r
}

// Filters by &#39;status&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqStatus(filterEqStatus string) ApiGetProjectLaunchesRequest {
	r.filterEqStatus = &filterEqStatus
	return r
}

// Filters by &#39;startTime&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqStartTime(filterEqStartTime string) ApiGetProjectLaunchesRequest {
	r.filterEqStartTime = &filterEqStartTime
	return r
}

// Filters by &#39;mode&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqMode(filterEqMode string) ApiGetProjectLaunchesRequest {
	r.filterEqMode = &filterEqMode
	return r
}

// Filters by &#39;hasRetries&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqHasRetries(filterEqHasRetries bool) ApiGetProjectLaunchesRequest {
	r.filterEqHasRetries = &filterEqHasRetries
	return r
}

// Filters by &#39;number&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqNumber(filterEqNumber int32) ApiGetProjectLaunchesRequest {
	r.filterEqNumber = &filterEqNumber
	return r
}

// Filters by &#39;lastModified&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqLastModified(filterEqLastModified string) ApiGetProjectLaunchesRequest {
	r.filterEqLastModified = &filterEqLastModified
	return r
}

// Filters by &#39;projectId&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqProjectId(filterEqProjectId int32) ApiGetProjectLaunchesRequest {
	r.filterEqProjectId = &filterEqProjectId
	return r
}

// Filters by &#39;compositeAttribute&#39;
func (r ApiGetProjectLaunchesRequest) FilterHasCompositeAttribute(filterHasCompositeAttribute string) ApiGetProjectLaunchesRequest {
	r.filterHasCompositeAttribute = &filterHasCompositeAttribute
	return r
}

// Filters by &#39;endTime&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqEndTime(filterEqEndTime string) ApiGetProjectLaunchesRequest {
	r.filterEqEndTime = &filterEqEndTime
	return r
}

// Filters by &#39;statistics$executions$passed&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqStatisticsexecutionspassed(filterEqStatisticsexecutionspassed int32) ApiGetProjectLaunchesRequest {
	r.filterEqStatisticsexecutionspassed = &filterEqStatisticsexecutionspassed
	return r
}

// Filters by &#39;name&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqName(filterEqName string) ApiGetProjectLaunchesRequest {
	r.filterEqName = &filterEqName
	return r
}

// Filters by &#39;statistics$defects$no_defect$nd001&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqStatisticsdefectsnoDefectnd001(filterEqStatisticsdefectsnoDefectnd001 int32) ApiGetProjectLaunchesRequest {
	r.filterEqStatisticsdefectsnoDefectnd001 = &filterEqStatisticsdefectsnoDefectnd001
	return r
}

// Filters by &#39;description&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqDescription(filterEqDescription string) ApiGetProjectLaunchesRequest {
	r.filterEqDescription = &filterEqDescription
	return r
}

// Filters by &#39;user&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqUser(filterEqUser string) ApiGetProjectLaunchesRequest {
	r.filterEqUser = &filterEqUser
	return r
}

// Filters by &#39;statistics$executions$failed&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqStatisticsexecutionsfailed(filterEqStatisticsexecutionsfailed int32) ApiGetProjectLaunchesRequest {
	r.filterEqStatisticsexecutionsfailed = &filterEqStatisticsexecutionsfailed
	return r
}

// Filters by &#39;statistics$defects$system_issue$si001&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqStatisticsdefectssystemIssuesi001(filterEqStatisticsdefectssystemIssuesi001 int32) ApiGetProjectLaunchesRequest {
	r.filterEqStatisticsdefectssystemIssuesi001 = &filterEqStatisticsdefectssystemIssuesi001
	return r
}

// Filters by &#39;attributeValue&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqAttributeValue(filterEqAttributeValue string) ApiGetProjectLaunchesRequest {
	r.filterEqAttributeValue = &filterEqAttributeValue
	return r
}

// Filters by &#39;statistics$executions$total&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqStatisticsexecutionstotal(filterEqStatisticsexecutionstotal int32) ApiGetProjectLaunchesRequest {
	r.filterEqStatisticsexecutionstotal = &filterEqStatisticsexecutionstotal
	return r
}

// Filters by &#39;statistics$executions$skipped&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqStatisticsexecutionsskipped(filterEqStatisticsexecutionsskipped int32) ApiGetProjectLaunchesRequest {
	r.filterEqStatisticsexecutionsskipped = &filterEqStatisticsexecutionsskipped
	return r
}

// Filters by &#39;statistics$defects$to_investigate$ti001&#39;
func (r ApiGetProjectLaunchesRequest) FilterEqStatisticsdefectstoInvestigateti001(filterEqStatisticsdefectstoInvestigateti001 int32) ApiGetProjectLaunchesRequest {
	r.filterEqStatisticsdefectstoInvestigateti001 = &filterEqStatisticsdefectstoInvestigateti001
	return r
}

// Results page you want to retrieve (0..N)
func (r ApiGetProjectLaunchesRequest) PagePage(pagePage int32) ApiGetProjectLaunchesRequest {
	r.pagePage = &pagePage
	return r
}

// Number of records per page
func (r ApiGetProjectLaunchesRequest) PageSize(pageSize int32) ApiGetProjectLaunchesRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetProjectLaunchesRequest) PageSort(pageSort string) ApiGetProjectLaunchesRequest {
	r.pageSort = &pageSort
	return r
}

func (r ApiGetProjectLaunchesRequest) Execute() (*PageLaunchResource, *http.Response, error) {
	return r.ApiService.GetProjectLaunchesExecute(r)
}

/*
GetProjectLaunches Get list of project launches by filter

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetProjectLaunchesRequest
*/
func (a *LaunchAPIService) GetProjectLaunches(ctx context.Context, projectName string) ApiGetProjectLaunchesRequest {
	return ApiGetProjectLaunchesRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return PageLaunchResource
func (a *LaunchAPIService) GetProjectLaunchesExecute(r ApiGetProjectLaunchesRequest) (*PageLaunchResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageLaunchResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.GetProjectLaunches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterEqStatisticsdefectsproductBugpb001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$product_bug$pb001", r.filterEqStatisticsdefectsproductBugpb001, "form", "")
	}
	if r.filterEqUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.uuid", r.filterEqUuid, "form", "")
	}
	if r.filterEqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.id", r.filterEqId, "form", "")
	}
	if r.filterEqStatisticsdefectsautomationBugab001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$automation_bug$ab001", r.filterEqStatisticsdefectsautomationBugab001, "form", "")
	}
	if r.filterEqAttributeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeKey", r.filterEqAttributeKey, "form", "")
	}
	if r.filterEqUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.userId", r.filterEqUserId, "form", "")
	}
	if r.filterEqStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.status", r.filterEqStatus, "form", "")
	}
	if r.filterEqStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.startTime", r.filterEqStartTime, "form", "")
	}
	if r.filterEqMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.mode", r.filterEqMode, "form", "")
	}
	if r.filterEqHasRetries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.hasRetries", r.filterEqHasRetries, "form", "")
	}
	if r.filterEqNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.number", r.filterEqNumber, "form", "")
	}
	if r.filterEqLastModified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.lastModified", r.filterEqLastModified, "form", "")
	}
	if r.filterEqProjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.projectId", r.filterEqProjectId, "form", "")
	}
	if r.filterHasCompositeAttribute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.has.compositeAttribute", r.filterHasCompositeAttribute, "form", "")
	}
	if r.filterEqEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.endTime", r.filterEqEndTime, "form", "")
	}
	if r.filterEqStatisticsexecutionspassed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$passed", r.filterEqStatisticsexecutionspassed, "form", "")
	}
	if r.filterEqName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.name", r.filterEqName, "form", "")
	}
	if r.filterEqStatisticsdefectsnoDefectnd001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$no_defect$nd001", r.filterEqStatisticsdefectsnoDefectnd001, "form", "")
	}
	if r.filterEqDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.description", r.filterEqDescription, "form", "")
	}
	if r.filterEqUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.user", r.filterEqUser, "form", "")
	}
	if r.filterEqStatisticsexecutionsfailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$failed", r.filterEqStatisticsexecutionsfailed, "form", "")
	}
	if r.filterEqStatisticsdefectssystemIssuesi001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$system_issue$si001", r.filterEqStatisticsdefectssystemIssuesi001, "form", "")
	}
	if r.filterEqAttributeValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeValue", r.filterEqAttributeValue, "form", "")
	}
	if r.filterEqStatisticsexecutionstotal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$total", r.filterEqStatisticsexecutionstotal, "form", "")
	}
	if r.filterEqStatisticsexecutionsskipped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$skipped", r.filterEqStatisticsexecutionsskipped, "form", "")
	}
	if r.filterEqStatisticsdefectstoInvestigateti001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$to_investigate$ti001", r.filterEqStatisticsdefectstoInvestigateti001, "form", "")
	}
	if r.pagePage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.page", r.pagePage, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.sort", r.pageSort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStatusesRequest struct {
	ctx         context.Context
	ApiService  *LaunchAPIService
	ids         *[]int64
	projectName string
}

func (r ApiGetStatusesRequest) Ids(ids []int64) ApiGetStatusesRequest {
	r.ids = &ids
	return r
}

func (r ApiGetStatusesRequest) Execute() (map[string]string, *http.Response, error) {
	return r.ApiService.GetStatusesExecute(r)
}

/*
GetStatuses Get Statuses

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetStatusesRequest
*/
func (a *LaunchAPIService) GetStatuses(ctx context.Context, projectName string) ApiGetStatusesRequest {
	return ApiGetStatusesRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return map[string]string
func (a *LaunchAPIService) GetStatusesExecute(r ApiGetStatusesRequest) (map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.GetStatuses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/status"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	{
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMergeLaunchesOldUuid1Request struct {
	ctx             context.Context
	ApiService      *LaunchAPIService
	projectName     string
	mergeLaunchesRQ *MergeLaunchesRQ
}

func (r ApiMergeLaunchesOldUuid1Request) MergeLaunchesRQ(mergeLaunchesRQ MergeLaunchesRQ) ApiMergeLaunchesOldUuid1Request {
	r.mergeLaunchesRQ = &mergeLaunchesRQ
	return r
}

func (r ApiMergeLaunchesOldUuid1Request) Execute() (*LaunchResourceOld, *http.Response, error) {
	return r.ApiService.MergeLaunchesOldUuid1Execute(r)
}

/*
MergeLaunchesOldUuid1 Merge set of specified launches in common one

This operation merges a set of launches into a common one. The IDs of the launches to be merged should be provided in the 'launches' field of the request body.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiMergeLaunchesOldUuid1Request
*/
func (a *LaunchAPIService) MergeLaunchesOldUuid1(ctx context.Context, projectName string) ApiMergeLaunchesOldUuid1Request {
	return ApiMergeLaunchesOldUuid1Request{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return LaunchResourceOld
func (a *LaunchAPIService) MergeLaunchesOldUuid1Execute(r ApiMergeLaunchesOldUuid1Request) (*LaunchResourceOld, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LaunchResourceOld
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.MergeLaunchesOldUuid1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/merge"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mergeLaunchesRQ == nil {
		return localVarReturnValue, nil, reportError("mergeLaunchesRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x.reportportal.launch.v2+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mergeLaunchesRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartLaunch1Request struct {
	ctx           context.Context
	ApiService    *LaunchAPIService
	projectName   string
	startLaunchRQ *StartLaunchRQ
}

func (r ApiStartLaunch1Request) StartLaunchRQ(startLaunchRQ StartLaunchRQ) ApiStartLaunch1Request {
	r.startLaunchRQ = &startLaunchRQ
	return r
}

func (r ApiStartLaunch1Request) Execute() (*StartLaunchRS, *http.Response, error) {
	return r.ApiService.StartLaunch1Execute(r)
}

/*
StartLaunch1 Starts launch for specified project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiStartLaunch1Request
*/
func (a *LaunchAPIService) StartLaunch1(ctx context.Context, projectName string) ApiStartLaunch1Request {
	return ApiStartLaunch1Request{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return StartLaunchRS
func (a *LaunchAPIService) StartLaunch1Execute(r ApiStartLaunch1Request) (*StartLaunchRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StartLaunchRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.StartLaunch1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startLaunchRQ == nil {
		return localVarReturnValue, nil, reportError("startLaunchRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startLaunchRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartLaunchAnalyzerRequest struct {
	ctx             context.Context
	ApiService      *LaunchAPIService
	projectName     string
	analyzeLaunchRQ *AnalyzeLaunchRQ
}

func (r ApiStartLaunchAnalyzerRequest) AnalyzeLaunchRQ(analyzeLaunchRQ AnalyzeLaunchRQ) ApiStartLaunchAnalyzerRequest {
	r.analyzeLaunchRQ = &analyzeLaunchRQ
	return r
}

func (r ApiStartLaunchAnalyzerRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.StartLaunchAnalyzerExecute(r)
}

/*
StartLaunchAnalyzer Start launch auto-analyzer on demand

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiStartLaunchAnalyzerRequest
*/
func (a *LaunchAPIService) StartLaunchAnalyzer(ctx context.Context, projectName string) ApiStartLaunchAnalyzerRequest {
	return ApiStartLaunchAnalyzerRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *LaunchAPIService) StartLaunchAnalyzerExecute(r ApiStartLaunchAnalyzerRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.StartLaunchAnalyzer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/analyze"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.analyzeLaunchRQ == nil {
		return localVarReturnValue, nil, reportError("analyzeLaunchRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.analyzeLaunchRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateLaunchRequest struct {
	ctx            context.Context
	ApiService     *LaunchAPIService
	launchId       int64
	projectName    string
	updateLaunchRQ *UpdateLaunchRQ
}

func (r ApiUpdateLaunchRequest) UpdateLaunchRQ(updateLaunchRQ UpdateLaunchRQ) ApiUpdateLaunchRequest {
	r.updateLaunchRQ = &updateLaunchRQ
	return r
}

func (r ApiUpdateLaunchRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.UpdateLaunchExecute(r)
}

/*
UpdateLaunch Updates launch for specified project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param launchId
	@param projectName
	@return ApiUpdateLaunchRequest
*/
func (a *LaunchAPIService) UpdateLaunch(ctx context.Context, launchId int64, projectName string) ApiUpdateLaunchRequest {
	return ApiUpdateLaunchRequest{
		ApiService:  a,
		ctx:         ctx,
		launchId:    launchId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *LaunchAPIService) UpdateLaunchExecute(r ApiUpdateLaunchRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.UpdateLaunch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/{launchId}/update"
	localVarPath = strings.Replace(localVarPath, "{"+"launchId"+"}", url.PathEscape(parameterValueToString(r.launchId, "launchId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateLaunchRQ == nil {
		return localVarReturnValue, nil, reportError("updateLaunchRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateLaunchRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateLaunchesRequest struct {
	ctx                      context.Context
	ApiService               *LaunchAPIService
	projectName              string
	bulkRQLongUpdateLaunchRQ *BulkRQLongUpdateLaunchRQ
}

func (r ApiUpdateLaunchesRequest) BulkRQLongUpdateLaunchRQ(bulkRQLongUpdateLaunchRQ BulkRQLongUpdateLaunchRQ) ApiUpdateLaunchesRequest {
	r.bulkRQLongUpdateLaunchRQ = &bulkRQLongUpdateLaunchRQ
	return r
}

func (r ApiUpdateLaunchesRequest) Execute() ([]OperationCompletionRS, *http.Response, error) {
	return r.ApiService.UpdateLaunchesExecute(r)
}

/*
UpdateLaunches Updates launches for specified project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiUpdateLaunchesRequest
*/
func (a *LaunchAPIService) UpdateLaunches(ctx context.Context, projectName string) ApiUpdateLaunchesRequest {
	return ApiUpdateLaunchesRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []OperationCompletionRS
func (a *LaunchAPIService) UpdateLaunchesExecute(r ApiUpdateLaunchesRequest) ([]OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LaunchAPIService.UpdateLaunches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/launch/update"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkRQLongUpdateLaunchRQ == nil {
		return localVarReturnValue, nil, reportError("bulkRQLongUpdateLaunchRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkRQLongUpdateLaunchRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v SaveAnalyticsSettings1401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRS
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
