/*
ReportPortal

ReportPortal API documentation

API version: develop-322
Contact: support@reportportal.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// UserFilterAPIService UserFilterAPI service
type UserFilterAPIService service

type ApiCreateFilterRequest struct {
	ctx                context.Context
	ApiService         *UserFilterAPIService
	projectName        string
	updateUserFilterRQ *UpdateUserFilterRQ
}

func (r ApiCreateFilterRequest) UpdateUserFilterRQ(updateUserFilterRQ UpdateUserFilterRQ) ApiCreateFilterRequest {
	r.updateUserFilterRQ = &updateUserFilterRQ
	return r
}

func (r ApiCreateFilterRequest) Execute() (*EntryCreatedRS, *http.Response, error) {
	return r.ApiService.CreateFilterExecute(r)
}

/*
CreateFilter Create user filter

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiCreateFilterRequest
*/
func (a *UserFilterAPIService) CreateFilter(ctx context.Context, projectName string) ApiCreateFilterRequest {
	return ApiCreateFilterRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return EntryCreatedRS
func (a *UserFilterAPIService) CreateFilterExecute(r ApiCreateFilterRequest) (*EntryCreatedRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EntryCreatedRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserFilterAPIService.CreateFilter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/filter"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateUserFilterRQ == nil {
		return localVarReturnValue, nil, reportError("updateUserFilterRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateUserFilterRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFilterRequest struct {
	ctx         context.Context
	ApiService  *UserFilterAPIService
	filterId    int64
	projectName string
}

func (r ApiDeleteFilterRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.DeleteFilterExecute(r)
}

/*
DeleteFilter Delete specified user filter by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param filterId
	@param projectName
	@return ApiDeleteFilterRequest
*/
func (a *UserFilterAPIService) DeleteFilter(ctx context.Context, filterId int64, projectName string) ApiDeleteFilterRequest {
	return ApiDeleteFilterRequest{
		ApiService:  a,
		ctx:         ctx,
		filterId:    filterId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *UserFilterAPIService) DeleteFilterExecute(r ApiDeleteFilterRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserFilterAPIService.DeleteFilter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/filter/{filterId}"
	localVarPath = strings.Replace(localVarPath, "{"+"filterId"+"}", url.PathEscape(parameterValueToString(r.filterId, "filterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllFiltersRequest struct {
	ctx               context.Context
	ApiService        *UserFilterAPIService
	projectName       string
	pagePage          *int32
	pageSize          *int32
	pageSort          *string
	filterEqOwner     *string
	filterEqId        *int32
	filterEqName      *string
	filterEqProjectId *int32
}

// Results page you want to retrieve (0..N)
func (r ApiGetAllFiltersRequest) PagePage(pagePage int32) ApiGetAllFiltersRequest {
	r.pagePage = &pagePage
	return r
}

// Number of records per page
func (r ApiGetAllFiltersRequest) PageSize(pageSize int32) ApiGetAllFiltersRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetAllFiltersRequest) PageSort(pageSort string) ApiGetAllFiltersRequest {
	r.pageSort = &pageSort
	return r
}

// Filters by &#39;owner&#39;
func (r ApiGetAllFiltersRequest) FilterEqOwner(filterEqOwner string) ApiGetAllFiltersRequest {
	r.filterEqOwner = &filterEqOwner
	return r
}

// Filters by &#39;id&#39;
func (r ApiGetAllFiltersRequest) FilterEqId(filterEqId int32) ApiGetAllFiltersRequest {
	r.filterEqId = &filterEqId
	return r
}

// Filters by &#39;name&#39;
func (r ApiGetAllFiltersRequest) FilterEqName(filterEqName string) ApiGetAllFiltersRequest {
	r.filterEqName = &filterEqName
	return r
}

// Filters by &#39;projectId&#39;
func (r ApiGetAllFiltersRequest) FilterEqProjectId(filterEqProjectId int32) ApiGetAllFiltersRequest {
	r.filterEqProjectId = &filterEqProjectId
	return r
}

func (r ApiGetAllFiltersRequest) Execute() (*PageUserFilterResource, *http.Response, error) {
	return r.ApiService.GetAllFiltersExecute(r)
}

/*
GetAllFilters Get filters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetAllFiltersRequest
*/
func (a *UserFilterAPIService) GetAllFilters(ctx context.Context, projectName string) ApiGetAllFiltersRequest {
	return ApiGetAllFiltersRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return PageUserFilterResource
func (a *UserFilterAPIService) GetAllFiltersExecute(r ApiGetAllFiltersRequest) (*PageUserFilterResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageUserFilterResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserFilterAPIService.GetAllFilters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/filter"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pagePage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.page", r.pagePage, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.sort", r.pageSort, "form", "")
	}
	if r.filterEqOwner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.owner", r.filterEqOwner, "form", "")
	}
	if r.filterEqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.id", r.filterEqId, "form", "")
	}
	if r.filterEqName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.name", r.filterEqName, "form", "")
	}
	if r.filterEqProjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.projectId", r.filterEqProjectId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllFiltersNamesRequest struct {
	ctx               context.Context
	ApiService        *UserFilterAPIService
	projectName       string
	pagePage          *int32
	pageSize          *int32
	pageSort          *string
	filterEqOwner     *string
	filterEqId        *int32
	filterEqName      *string
	filterEqProjectId *int32
}

// Results page you want to retrieve (0..N)
func (r ApiGetAllFiltersNamesRequest) PagePage(pagePage int32) ApiGetAllFiltersNamesRequest {
	r.pagePage = &pagePage
	return r
}

// Number of records per page
func (r ApiGetAllFiltersNamesRequest) PageSize(pageSize int32) ApiGetAllFiltersNamesRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetAllFiltersNamesRequest) PageSort(pageSort string) ApiGetAllFiltersNamesRequest {
	r.pageSort = &pageSort
	return r
}

// Filters by &#39;owner&#39;
func (r ApiGetAllFiltersNamesRequest) FilterEqOwner(filterEqOwner string) ApiGetAllFiltersNamesRequest {
	r.filterEqOwner = &filterEqOwner
	return r
}

// Filters by &#39;id&#39;
func (r ApiGetAllFiltersNamesRequest) FilterEqId(filterEqId int32) ApiGetAllFiltersNamesRequest {
	r.filterEqId = &filterEqId
	return r
}

// Filters by &#39;name&#39;
func (r ApiGetAllFiltersNamesRequest) FilterEqName(filterEqName string) ApiGetAllFiltersNamesRequest {
	r.filterEqName = &filterEqName
	return r
}

// Filters by &#39;projectId&#39;
func (r ApiGetAllFiltersNamesRequest) FilterEqProjectId(filterEqProjectId int32) ApiGetAllFiltersNamesRequest {
	r.filterEqProjectId = &filterEqProjectId
	return r
}

func (r ApiGetAllFiltersNamesRequest) Execute() (*PageOwnedEntityResource, *http.Response, error) {
	return r.ApiService.GetAllFiltersNamesExecute(r)
}

/*
GetAllFiltersNames Get available filter names

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetAllFiltersNamesRequest
*/
func (a *UserFilterAPIService) GetAllFiltersNames(ctx context.Context, projectName string) ApiGetAllFiltersNamesRequest {
	return ApiGetAllFiltersNamesRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return PageOwnedEntityResource
func (a *UserFilterAPIService) GetAllFiltersNamesExecute(r ApiGetAllFiltersNamesRequest) (*PageOwnedEntityResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageOwnedEntityResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserFilterAPIService.GetAllFiltersNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/filter/names"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pagePage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.page", r.pagePage, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.sort", r.pageSort, "form", "")
	}
	if r.filterEqOwner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.owner", r.filterEqOwner, "form", "")
	}
	if r.filterEqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.id", r.filterEqId, "form", "")
	}
	if r.filterEqName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.name", r.filterEqName, "form", "")
	}
	if r.filterEqProjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.projectId", r.filterEqProjectId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFilterRequest struct {
	ctx         context.Context
	ApiService  *UserFilterAPIService
	filterId    int64
	projectName string
}

func (r ApiGetFilterRequest) Execute() (*UserFilterResource, *http.Response, error) {
	return r.ApiService.GetFilterExecute(r)
}

/*
GetFilter Get specified user filter by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param filterId
	@param projectName
	@return ApiGetFilterRequest
*/
func (a *UserFilterAPIService) GetFilter(ctx context.Context, filterId int64, projectName string) ApiGetFilterRequest {
	return ApiGetFilterRequest{
		ApiService:  a,
		ctx:         ctx,
		filterId:    filterId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return UserFilterResource
func (a *UserFilterAPIService) GetFilterExecute(r ApiGetFilterRequest) (*UserFilterResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserFilterResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserFilterAPIService.GetFilter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/filter/{filterId}"
	localVarPath = strings.Replace(localVarPath, "{"+"filterId"+"}", url.PathEscape(parameterValueToString(r.filterId, "filterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserFiltersRequest struct {
	ctx         context.Context
	ApiService  *UserFilterAPIService
	ids         *[]int64
	projectName string
}

func (r ApiGetUserFiltersRequest) Ids(ids []int64) ApiGetUserFiltersRequest {
	r.ids = &ids
	return r
}

func (r ApiGetUserFiltersRequest) Execute() ([]UserFilterResource, *http.Response, error) {
	return r.ApiService.GetUserFiltersExecute(r)
}

/*
GetUserFilters Get list of specified user filters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetUserFiltersRequest
*/
func (a *UserFilterAPIService) GetUserFilters(ctx context.Context, projectName string) ApiGetUserFiltersRequest {
	return ApiGetUserFiltersRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []UserFilterResource
func (a *UserFilterAPIService) GetUserFiltersExecute(r ApiGetUserFiltersRequest) ([]UserFilterResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UserFilterResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserFilterAPIService.GetUserFilters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/filter/filters"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	{
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUserFilterRequest struct {
	ctx                context.Context
	ApiService         *UserFilterAPIService
	filterId           int64
	projectName        string
	updateUserFilterRQ *UpdateUserFilterRQ
}

func (r ApiUpdateUserFilterRequest) UpdateUserFilterRQ(updateUserFilterRQ UpdateUserFilterRQ) ApiUpdateUserFilterRequest {
	r.updateUserFilterRQ = &updateUserFilterRQ
	return r
}

func (r ApiUpdateUserFilterRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.UpdateUserFilterExecute(r)
}

/*
UpdateUserFilter Update specified user filter

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param filterId
	@param projectName
	@return ApiUpdateUserFilterRequest
*/
func (a *UserFilterAPIService) UpdateUserFilter(ctx context.Context, filterId int64, projectName string) ApiUpdateUserFilterRequest {
	return ApiUpdateUserFilterRequest{
		ApiService:  a,
		ctx:         ctx,
		filterId:    filterId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *UserFilterAPIService) UpdateUserFilterExecute(r ApiUpdateUserFilterRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserFilterAPIService.UpdateUserFilter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/filter/{filterId}"
	localVarPath = strings.Replace(localVarPath, "{"+"filterId"+"}", url.PathEscape(parameterValueToString(r.filterId, "filterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateUserFilterRQ == nil {
		return localVarReturnValue, nil, reportError("updateUserFilterRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateUserFilterRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUserFiltersRequest struct {
	ctx                             context.Context
	ApiService                      *UserFilterAPIService
	projectName                     string
	collectionsRQBulkUpdateFilterRQ *CollectionsRQBulkUpdateFilterRQ
}

func (r ApiUpdateUserFiltersRequest) CollectionsRQBulkUpdateFilterRQ(collectionsRQBulkUpdateFilterRQ CollectionsRQBulkUpdateFilterRQ) ApiUpdateUserFiltersRequest {
	r.collectionsRQBulkUpdateFilterRQ = &collectionsRQBulkUpdateFilterRQ
	return r
}

func (r ApiUpdateUserFiltersRequest) Execute() ([]OperationCompletionRS, *http.Response, error) {
	return r.ApiService.UpdateUserFiltersExecute(r)
}

/*
UpdateUserFilters Update list of user filters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiUpdateUserFiltersRequest
*/
func (a *UserFilterAPIService) UpdateUserFilters(ctx context.Context, projectName string) ApiUpdateUserFiltersRequest {
	return ApiUpdateUserFiltersRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []OperationCompletionRS
func (a *UserFilterAPIService) UpdateUserFiltersExecute(r ApiUpdateUserFiltersRequest) ([]OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserFilterAPIService.UpdateUserFilters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/filter"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.collectionsRQBulkUpdateFilterRQ == nil {
		return localVarReturnValue, nil, reportError("collectionsRQBulkUpdateFilterRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.collectionsRQBulkUpdateFilterRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
