/*
ReportPortal

ReportPortal API documentation

API version: develop-322
Contact: support@reportportal.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// LogAPIService LogAPI service
type LogAPIService service

type ApiCreateLog1Request struct {
	ctx             context.Context
	ApiService      *LogAPIService
	projectName     string
	jsonRequestPart *[]SaveLogRQ
}

func (r ApiCreateLog1Request) JsonRequestPart(jsonRequestPart []SaveLogRQ) ApiCreateLog1Request {
	r.jsonRequestPart = &jsonRequestPart
	return r
}

func (r ApiCreateLog1Request) Execute() (*BatchSaveOperatingRS, *http.Response, error) {
	return r.ApiService.CreateLog1Execute(r)
}

/*
CreateLog1 Create log (batching operation)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiCreateLog1Request
*/
func (a *LogAPIService) CreateLog1(ctx context.Context, projectName string) ApiCreateLog1Request {
	return ApiCreateLog1Request{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return BatchSaveOperatingRS
func (a *LogAPIService) CreateLog1Execute(r ApiCreateLog1Request) (*BatchSaveOperatingRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BatchSaveOperatingRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogAPIService.CreateLog1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/log"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jsonRequestPart == nil {
		return localVarReturnValue, nil, reportError("jsonRequestPart is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "json_request_part", r.jsonRequestPart, "", "csv")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateLogEntry1Request struct {
	ctx         context.Context
	ApiService  *LogAPIService
	projectName string
	saveLogRQ   *SaveLogRQ
}

func (r ApiCreateLogEntry1Request) SaveLogRQ(saveLogRQ SaveLogRQ) ApiCreateLogEntry1Request {
	r.saveLogRQ = &saveLogRQ
	return r
}

func (r ApiCreateLogEntry1Request) Execute() (*EntryCreatedAsyncRS, *http.Response, error) {
	return r.ApiService.CreateLogEntry1Execute(r)
}

/*
CreateLogEntry1 Create log

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiCreateLogEntry1Request
*/
func (a *LogAPIService) CreateLogEntry1(ctx context.Context, projectName string) ApiCreateLogEntry1Request {
	return ApiCreateLogEntry1Request{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return EntryCreatedAsyncRS
func (a *LogAPIService) CreateLogEntry1Execute(r ApiCreateLogEntry1Request) (*EntryCreatedAsyncRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EntryCreatedAsyncRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogAPIService.CreateLogEntry1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/log/entry"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.saveLogRQ == nil {
		return localVarReturnValue, nil, reportError("saveLogRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.saveLogRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteLogRequest struct {
	ctx         context.Context
	ApiService  *LogAPIService
	logId       int64
	projectName string
}

func (r ApiDeleteLogRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.DeleteLogExecute(r)
}

/*
DeleteLog Delete log

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param logId
	@param projectName
	@return ApiDeleteLogRequest
*/
func (a *LogAPIService) DeleteLog(ctx context.Context, logId int64, projectName string) ApiDeleteLogRequest {
	return ApiDeleteLogRequest{
		ApiService:  a,
		ctx:         ctx,
		logId:       logId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *LogAPIService) DeleteLogExecute(r ApiDeleteLogRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogAPIService.DeleteLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/log/{logId}"
	localVarPath = strings.Replace(localVarPath, "{"+"logId"+"}", url.PathEscape(parameterValueToString(r.logId, "logId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetErrorPageRequest struct {
	ctx                         context.Context
	ApiService                  *LogAPIService
	params                      *map[string]string
	parentId                    int64
	projectName                 string
	filterEqItem                *int32
	filterEqLevel               *string
	filterEqMessage             *string
	filterEqId                  *int32
	filterEqPath                *string
	filterEqAutoAnalyzed        *bool
	filterEqLaunchId            *int32
	filterEqLaunch              *int32
	filterEqStatus              *string
	filterEqRetryParentId       *int32
	filterEqLogId               *int32
	filterEqLastModified        *string
	filterEqBinaryContent       *string
	filterEqLogTime             *string
	filterEqProjectId           *int32
	filterEqRetryParentLaunchId *int32
	pagePage                    *int32
	pageSize                    *int32
	pageSort                    *string
}

func (r ApiGetErrorPageRequest) Params(params map[string]string) ApiGetErrorPageRequest {
	r.params = &params
	return r
}

// Filters by &#39;item&#39;
func (r ApiGetErrorPageRequest) FilterEqItem(filterEqItem int32) ApiGetErrorPageRequest {
	r.filterEqItem = &filterEqItem
	return r
}

// Filters by &#39;level&#39;
func (r ApiGetErrorPageRequest) FilterEqLevel(filterEqLevel string) ApiGetErrorPageRequest {
	r.filterEqLevel = &filterEqLevel
	return r
}

// Filters by &#39;message&#39;
func (r ApiGetErrorPageRequest) FilterEqMessage(filterEqMessage string) ApiGetErrorPageRequest {
	r.filterEqMessage = &filterEqMessage
	return r
}

// Filters by &#39;id&#39;
func (r ApiGetErrorPageRequest) FilterEqId(filterEqId int32) ApiGetErrorPageRequest {
	r.filterEqId = &filterEqId
	return r
}

// Filters by &#39;path&#39;
func (r ApiGetErrorPageRequest) FilterEqPath(filterEqPath string) ApiGetErrorPageRequest {
	r.filterEqPath = &filterEqPath
	return r
}

// Filters by &#39;autoAnalyzed&#39;
func (r ApiGetErrorPageRequest) FilterEqAutoAnalyzed(filterEqAutoAnalyzed bool) ApiGetErrorPageRequest {
	r.filterEqAutoAnalyzed = &filterEqAutoAnalyzed
	return r
}

// Filters by &#39;launchId&#39;
func (r ApiGetErrorPageRequest) FilterEqLaunchId(filterEqLaunchId int32) ApiGetErrorPageRequest {
	r.filterEqLaunchId = &filterEqLaunchId
	return r
}

// Filters by &#39;launch&#39;
func (r ApiGetErrorPageRequest) FilterEqLaunch(filterEqLaunch int32) ApiGetErrorPageRequest {
	r.filterEqLaunch = &filterEqLaunch
	return r
}

// Filters by &#39;status&#39;
func (r ApiGetErrorPageRequest) FilterEqStatus(filterEqStatus string) ApiGetErrorPageRequest {
	r.filterEqStatus = &filterEqStatus
	return r
}

// Filters by &#39;retryParentId&#39;
func (r ApiGetErrorPageRequest) FilterEqRetryParentId(filterEqRetryParentId int32) ApiGetErrorPageRequest {
	r.filterEqRetryParentId = &filterEqRetryParentId
	return r
}

// Filters by &#39;logId&#39;
func (r ApiGetErrorPageRequest) FilterEqLogId(filterEqLogId int32) ApiGetErrorPageRequest {
	r.filterEqLogId = &filterEqLogId
	return r
}

// Filters by &#39;lastModified&#39;
func (r ApiGetErrorPageRequest) FilterEqLastModified(filterEqLastModified string) ApiGetErrorPageRequest {
	r.filterEqLastModified = &filterEqLastModified
	return r
}

// Filters by &#39;binaryContent&#39;
func (r ApiGetErrorPageRequest) FilterEqBinaryContent(filterEqBinaryContent string) ApiGetErrorPageRequest {
	r.filterEqBinaryContent = &filterEqBinaryContent
	return r
}

// Filters by &#39;logTime&#39;
func (r ApiGetErrorPageRequest) FilterEqLogTime(filterEqLogTime string) ApiGetErrorPageRequest {
	r.filterEqLogTime = &filterEqLogTime
	return r
}

// Filters by &#39;projectId&#39;
func (r ApiGetErrorPageRequest) FilterEqProjectId(filterEqProjectId int32) ApiGetErrorPageRequest {
	r.filterEqProjectId = &filterEqProjectId
	return r
}

// Filters by &#39;retryParentLaunchId&#39;
func (r ApiGetErrorPageRequest) FilterEqRetryParentLaunchId(filterEqRetryParentLaunchId int32) ApiGetErrorPageRequest {
	r.filterEqRetryParentLaunchId = &filterEqRetryParentLaunchId
	return r
}

// Results page you want to retrieve (0..N)
func (r ApiGetErrorPageRequest) PagePage(pagePage int32) ApiGetErrorPageRequest {
	r.pagePage = &pagePage
	return r
}

// Number of records per page
func (r ApiGetErrorPageRequest) PageSize(pageSize int32) ApiGetErrorPageRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetErrorPageRequest) PageSort(pageSort string) ApiGetErrorPageRequest {
	r.pageSort = &pageSort
	return r
}

func (r ApiGetErrorPageRequest) Execute() ([]PagedLogResource, *http.Response, error) {
	return r.ApiService.GetErrorPageExecute(r)
}

/*
GetErrorPage Get next or previous log in test item

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param parentId
	@param projectName
	@return ApiGetErrorPageRequest
*/
func (a *LogAPIService) GetErrorPage(ctx context.Context, parentId int64, projectName string) ApiGetErrorPageRequest {
	return ApiGetErrorPageRequest{
		ApiService:  a,
		ctx:         ctx,
		parentId:    parentId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []PagedLogResource
func (a *LogAPIService) GetErrorPageExecute(r ApiGetErrorPageRequest) ([]PagedLogResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []PagedLogResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogAPIService.GetErrorPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/log/locations/{parentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"parentId"+"}", url.PathEscape(parameterValueToString(r.parentId, "parentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.params == nil {
		return localVarReturnValue, nil, reportError("params is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	if r.filterEqItem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.item", r.filterEqItem, "form", "")
	}
	if r.filterEqLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.level", r.filterEqLevel, "form", "")
	}
	if r.filterEqMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.message", r.filterEqMessage, "form", "")
	}
	if r.filterEqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.id", r.filterEqId, "form", "")
	}
	if r.filterEqPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.path", r.filterEqPath, "form", "")
	}
	if r.filterEqAutoAnalyzed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.autoAnalyzed", r.filterEqAutoAnalyzed, "form", "")
	}
	if r.filterEqLaunchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.launchId", r.filterEqLaunchId, "form", "")
	}
	if r.filterEqLaunch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.launch", r.filterEqLaunch, "form", "")
	}
	if r.filterEqStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.status", r.filterEqStatus, "form", "")
	}
	if r.filterEqRetryParentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.retryParentId", r.filterEqRetryParentId, "form", "")
	}
	if r.filterEqLogId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.logId", r.filterEqLogId, "form", "")
	}
	if r.filterEqLastModified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.lastModified", r.filterEqLastModified, "form", "")
	}
	if r.filterEqBinaryContent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.binaryContent", r.filterEqBinaryContent, "form", "")
	}
	if r.filterEqLogTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.logTime", r.filterEqLogTime, "form", "")
	}
	if r.filterEqProjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.projectId", r.filterEqProjectId, "form", "")
	}
	if r.filterEqRetryParentLaunchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.retryParentLaunchId", r.filterEqRetryParentLaunchId, "form", "")
	}
	if r.pagePage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.page", r.pagePage, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.sort", r.pageSort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLogRequest struct {
	ctx         context.Context
	ApiService  *LogAPIService
	logId       string
	projectName string
}

func (r ApiGetLogRequest) Execute() (*LogResource, *http.Response, error) {
	return r.ApiService.GetLogExecute(r)
}

/*
GetLog Get log by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param logId
	@param projectName
	@return ApiGetLogRequest
*/
func (a *LogAPIService) GetLog(ctx context.Context, logId string, projectName string) ApiGetLogRequest {
	return ApiGetLogRequest{
		ApiService:  a,
		ctx:         ctx,
		logId:       logId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return LogResource
func (a *LogAPIService) GetLogExecute(r ApiGetLogRequest) (*LogResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LogResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogAPIService.GetLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/log/{logId}"
	localVarPath = strings.Replace(localVarPath, "{"+"logId"+"}", url.PathEscape(parameterValueToString(r.logId, "logId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLogByUuidRequest struct {
	ctx         context.Context
	ApiService  *LogAPIService
	logId       string
	projectName string
}

func (r ApiGetLogByUuidRequest) Execute() (*LogResource, *http.Response, error) {
	return r.ApiService.GetLogByUuidExecute(r)
}

/*
GetLogByUuid Get log by UUID (Will be removed in version 6.0)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param logId
	@param projectName
	@return ApiGetLogByUuidRequest

Deprecated
*/
func (a *LogAPIService) GetLogByUuid(ctx context.Context, logId string, projectName string) ApiGetLogByUuidRequest {
	return ApiGetLogByUuidRequest{
		ApiService:  a,
		ctx:         ctx,
		logId:       logId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return LogResource
//
// Deprecated
func (a *LogAPIService) GetLogByUuidExecute(r ApiGetLogByUuidRequest) (*LogResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LogResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogAPIService.GetLogByUuid")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/log/uuid/{logId}"
	localVarPath = strings.Replace(localVarPath, "{"+"logId"+"}", url.PathEscape(parameterValueToString(r.logId, "logId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLogsRequest struct {
	ctx                         context.Context
	ApiService                  *LogAPIService
	projectName                 string
	filterUnderPath             *string
	filterEqItem                *int32
	filterEqLevel               *string
	filterEqMessage             *string
	filterEqId                  *int32
	filterEqPath                *string
	filterEqAutoAnalyzed        *bool
	filterEqLaunchId            *int32
	filterEqLaunch              *int32
	filterEqStatus              *string
	filterEqRetryParentId       *int32
	filterEqLogId               *int32
	filterEqLastModified        *string
	filterEqBinaryContent       *string
	filterEqLogTime             *string
	filterEqProjectId           *int32
	filterEqRetryParentLaunchId *int32
	pagePage                    *int32
	pageSize                    *int32
	pageSort                    *string
}

func (r ApiGetLogsRequest) FilterUnderPath(filterUnderPath string) ApiGetLogsRequest {
	r.filterUnderPath = &filterUnderPath
	return r
}

// Filters by &#39;item&#39;
func (r ApiGetLogsRequest) FilterEqItem(filterEqItem int32) ApiGetLogsRequest {
	r.filterEqItem = &filterEqItem
	return r
}

// Filters by &#39;level&#39;
func (r ApiGetLogsRequest) FilterEqLevel(filterEqLevel string) ApiGetLogsRequest {
	r.filterEqLevel = &filterEqLevel
	return r
}

// Filters by &#39;message&#39;
func (r ApiGetLogsRequest) FilterEqMessage(filterEqMessage string) ApiGetLogsRequest {
	r.filterEqMessage = &filterEqMessage
	return r
}

// Filters by &#39;id&#39;
func (r ApiGetLogsRequest) FilterEqId(filterEqId int32) ApiGetLogsRequest {
	r.filterEqId = &filterEqId
	return r
}

// Filters by &#39;path&#39;
func (r ApiGetLogsRequest) FilterEqPath(filterEqPath string) ApiGetLogsRequest {
	r.filterEqPath = &filterEqPath
	return r
}

// Filters by &#39;autoAnalyzed&#39;
func (r ApiGetLogsRequest) FilterEqAutoAnalyzed(filterEqAutoAnalyzed bool) ApiGetLogsRequest {
	r.filterEqAutoAnalyzed = &filterEqAutoAnalyzed
	return r
}

// Filters by &#39;launchId&#39;
func (r ApiGetLogsRequest) FilterEqLaunchId(filterEqLaunchId int32) ApiGetLogsRequest {
	r.filterEqLaunchId = &filterEqLaunchId
	return r
}

// Filters by &#39;launch&#39;
func (r ApiGetLogsRequest) FilterEqLaunch(filterEqLaunch int32) ApiGetLogsRequest {
	r.filterEqLaunch = &filterEqLaunch
	return r
}

// Filters by &#39;status&#39;
func (r ApiGetLogsRequest) FilterEqStatus(filterEqStatus string) ApiGetLogsRequest {
	r.filterEqStatus = &filterEqStatus
	return r
}

// Filters by &#39;retryParentId&#39;
func (r ApiGetLogsRequest) FilterEqRetryParentId(filterEqRetryParentId int32) ApiGetLogsRequest {
	r.filterEqRetryParentId = &filterEqRetryParentId
	return r
}

// Filters by &#39;logId&#39;
func (r ApiGetLogsRequest) FilterEqLogId(filterEqLogId int32) ApiGetLogsRequest {
	r.filterEqLogId = &filterEqLogId
	return r
}

// Filters by &#39;lastModified&#39;
func (r ApiGetLogsRequest) FilterEqLastModified(filterEqLastModified string) ApiGetLogsRequest {
	r.filterEqLastModified = &filterEqLastModified
	return r
}

// Filters by &#39;binaryContent&#39;
func (r ApiGetLogsRequest) FilterEqBinaryContent(filterEqBinaryContent string) ApiGetLogsRequest {
	r.filterEqBinaryContent = &filterEqBinaryContent
	return r
}

// Filters by &#39;logTime&#39;
func (r ApiGetLogsRequest) FilterEqLogTime(filterEqLogTime string) ApiGetLogsRequest {
	r.filterEqLogTime = &filterEqLogTime
	return r
}

// Filters by &#39;projectId&#39;
func (r ApiGetLogsRequest) FilterEqProjectId(filterEqProjectId int32) ApiGetLogsRequest {
	r.filterEqProjectId = &filterEqProjectId
	return r
}

// Filters by &#39;retryParentLaunchId&#39;
func (r ApiGetLogsRequest) FilterEqRetryParentLaunchId(filterEqRetryParentLaunchId int32) ApiGetLogsRequest {
	r.filterEqRetryParentLaunchId = &filterEqRetryParentLaunchId
	return r
}

// Results page you want to retrieve (0..N)
func (r ApiGetLogsRequest) PagePage(pagePage int32) ApiGetLogsRequest {
	r.pagePage = &pagePage
	return r
}

// Number of records per page
func (r ApiGetLogsRequest) PageSize(pageSize int32) ApiGetLogsRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetLogsRequest) PageSort(pageSort string) ApiGetLogsRequest {
	r.pageSort = &pageSort
	return r
}

func (r ApiGetLogsRequest) Execute() (*PageLogResource, *http.Response, error) {
	return r.ApiService.GetLogsExecute(r)
}

/*
GetLogs Get logs by filter

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetLogsRequest
*/
func (a *LogAPIService) GetLogs(ctx context.Context, projectName string) ApiGetLogsRequest {
	return ApiGetLogsRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return PageLogResource
func (a *LogAPIService) GetLogsExecute(r ApiGetLogsRequest) (*PageLogResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageLogResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogAPIService.GetLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/log"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterUnderPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.under.path", r.filterUnderPath, "form", "")
	}
	if r.filterEqItem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.item", r.filterEqItem, "form", "")
	}
	if r.filterEqLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.level", r.filterEqLevel, "form", "")
	}
	if r.filterEqMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.message", r.filterEqMessage, "form", "")
	}
	if r.filterEqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.id", r.filterEqId, "form", "")
	}
	if r.filterEqPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.path", r.filterEqPath, "form", "")
	}
	if r.filterEqAutoAnalyzed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.autoAnalyzed", r.filterEqAutoAnalyzed, "form", "")
	}
	if r.filterEqLaunchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.launchId", r.filterEqLaunchId, "form", "")
	}
	if r.filterEqLaunch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.launch", r.filterEqLaunch, "form", "")
	}
	if r.filterEqStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.status", r.filterEqStatus, "form", "")
	}
	if r.filterEqRetryParentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.retryParentId", r.filterEqRetryParentId, "form", "")
	}
	if r.filterEqLogId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.logId", r.filterEqLogId, "form", "")
	}
	if r.filterEqLastModified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.lastModified", r.filterEqLastModified, "form", "")
	}
	if r.filterEqBinaryContent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.binaryContent", r.filterEqBinaryContent, "form", "")
	}
	if r.filterEqLogTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.logTime", r.filterEqLogTime, "form", "")
	}
	if r.filterEqProjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.projectId", r.filterEqProjectId, "form", "")
	}
	if r.filterEqRetryParentLaunchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.retryParentLaunchId", r.filterEqRetryParentLaunchId, "form", "")
	}
	if r.pagePage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.page", r.pagePage, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.sort", r.pageSort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLogsUnderRequest struct {
	ctx            context.Context
	ApiService     *LogAPIService
	projectName    string
	getLogsUnderRq *GetLogsUnderRq
}

func (r ApiGetLogsUnderRequest) GetLogsUnderRq(getLogsUnderRq GetLogsUnderRq) ApiGetLogsUnderRequest {
	r.getLogsUnderRq = &getLogsUnderRq
	return r
}

func (r ApiGetLogsUnderRequest) Execute() (*map[string][]LogResource, *http.Response, error) {
	return r.ApiService.GetLogsUnderExecute(r)
}

/*
GetLogsUnder Get logs under items

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetLogsUnderRequest
*/
func (a *LogAPIService) GetLogsUnder(ctx context.Context, projectName string) ApiGetLogsUnderRequest {
	return ApiGetLogsUnderRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return map[string][]LogResource
func (a *LogAPIService) GetLogsUnderExecute(r ApiGetLogsUnderRequest) (*map[string][]LogResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *map[string][]LogResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogAPIService.GetLogsUnder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/log/under"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getLogsUnderRq == nil {
		return localVarReturnValue, nil, reportError("getLogsUnderRq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getLogsUnderRq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNestedItemsRequest struct {
	ctx                         context.Context
	ApiService                  *LogAPIService
	params                      *map[string]string
	parentId                    int64
	projectName                 string
	filterEqItem                *int32
	filterEqLevel               *string
	filterEqMessage             *string
	filterEqId                  *int32
	filterEqPath                *string
	filterEqAutoAnalyzed        *bool
	filterEqLaunchId            *int32
	filterEqLaunch              *int32
	filterEqStatus              *string
	filterEqRetryParentId       *int32
	filterEqLogId               *int32
	filterEqLastModified        *string
	filterEqBinaryContent       *string
	filterEqLogTime             *string
	filterEqProjectId           *int32
	filterEqRetryParentLaunchId *int32
	pagePage                    *int32
	pageSize                    *int32
	pageSort                    *string
}

func (r ApiGetNestedItemsRequest) Params(params map[string]string) ApiGetNestedItemsRequest {
	r.params = &params
	return r
}

// Filters by &#39;item&#39;
func (r ApiGetNestedItemsRequest) FilterEqItem(filterEqItem int32) ApiGetNestedItemsRequest {
	r.filterEqItem = &filterEqItem
	return r
}

// Filters by &#39;level&#39;
func (r ApiGetNestedItemsRequest) FilterEqLevel(filterEqLevel string) ApiGetNestedItemsRequest {
	r.filterEqLevel = &filterEqLevel
	return r
}

// Filters by &#39;message&#39;
func (r ApiGetNestedItemsRequest) FilterEqMessage(filterEqMessage string) ApiGetNestedItemsRequest {
	r.filterEqMessage = &filterEqMessage
	return r
}

// Filters by &#39;id&#39;
func (r ApiGetNestedItemsRequest) FilterEqId(filterEqId int32) ApiGetNestedItemsRequest {
	r.filterEqId = &filterEqId
	return r
}

// Filters by &#39;path&#39;
func (r ApiGetNestedItemsRequest) FilterEqPath(filterEqPath string) ApiGetNestedItemsRequest {
	r.filterEqPath = &filterEqPath
	return r
}

// Filters by &#39;autoAnalyzed&#39;
func (r ApiGetNestedItemsRequest) FilterEqAutoAnalyzed(filterEqAutoAnalyzed bool) ApiGetNestedItemsRequest {
	r.filterEqAutoAnalyzed = &filterEqAutoAnalyzed
	return r
}

// Filters by &#39;launchId&#39;
func (r ApiGetNestedItemsRequest) FilterEqLaunchId(filterEqLaunchId int32) ApiGetNestedItemsRequest {
	r.filterEqLaunchId = &filterEqLaunchId
	return r
}

// Filters by &#39;launch&#39;
func (r ApiGetNestedItemsRequest) FilterEqLaunch(filterEqLaunch int32) ApiGetNestedItemsRequest {
	r.filterEqLaunch = &filterEqLaunch
	return r
}

// Filters by &#39;status&#39;
func (r ApiGetNestedItemsRequest) FilterEqStatus(filterEqStatus string) ApiGetNestedItemsRequest {
	r.filterEqStatus = &filterEqStatus
	return r
}

// Filters by &#39;retryParentId&#39;
func (r ApiGetNestedItemsRequest) FilterEqRetryParentId(filterEqRetryParentId int32) ApiGetNestedItemsRequest {
	r.filterEqRetryParentId = &filterEqRetryParentId
	return r
}

// Filters by &#39;logId&#39;
func (r ApiGetNestedItemsRequest) FilterEqLogId(filterEqLogId int32) ApiGetNestedItemsRequest {
	r.filterEqLogId = &filterEqLogId
	return r
}

// Filters by &#39;lastModified&#39;
func (r ApiGetNestedItemsRequest) FilterEqLastModified(filterEqLastModified string) ApiGetNestedItemsRequest {
	r.filterEqLastModified = &filterEqLastModified
	return r
}

// Filters by &#39;binaryContent&#39;
func (r ApiGetNestedItemsRequest) FilterEqBinaryContent(filterEqBinaryContent string) ApiGetNestedItemsRequest {
	r.filterEqBinaryContent = &filterEqBinaryContent
	return r
}

// Filters by &#39;logTime&#39;
func (r ApiGetNestedItemsRequest) FilterEqLogTime(filterEqLogTime string) ApiGetNestedItemsRequest {
	r.filterEqLogTime = &filterEqLogTime
	return r
}

// Filters by &#39;projectId&#39;
func (r ApiGetNestedItemsRequest) FilterEqProjectId(filterEqProjectId int32) ApiGetNestedItemsRequest {
	r.filterEqProjectId = &filterEqProjectId
	return r
}

// Filters by &#39;retryParentLaunchId&#39;
func (r ApiGetNestedItemsRequest) FilterEqRetryParentLaunchId(filterEqRetryParentLaunchId int32) ApiGetNestedItemsRequest {
	r.filterEqRetryParentLaunchId = &filterEqRetryParentLaunchId
	return r
}

// Results page you want to retrieve (0..N)
func (r ApiGetNestedItemsRequest) PagePage(pagePage int32) ApiGetNestedItemsRequest {
	r.pagePage = &pagePage
	return r
}

// Number of records per page
func (r ApiGetNestedItemsRequest) PageSize(pageSize int32) ApiGetNestedItemsRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetNestedItemsRequest) PageSort(pageSort string) ApiGetNestedItemsRequest {
	r.pageSort = &pageSort
	return r
}

func (r ApiGetNestedItemsRequest) Execute() (*PageObject, *http.Response, error) {
	return r.ApiService.GetNestedItemsExecute(r)
}

/*
GetNestedItems Get nested steps with logs for the parent Test Item

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param parentId
	@param projectName
	@return ApiGetNestedItemsRequest
*/
func (a *LogAPIService) GetNestedItems(ctx context.Context, parentId int64, projectName string) ApiGetNestedItemsRequest {
	return ApiGetNestedItemsRequest{
		ApiService:  a,
		ctx:         ctx,
		parentId:    parentId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return PageObject
func (a *LogAPIService) GetNestedItemsExecute(r ApiGetNestedItemsRequest) (*PageObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogAPIService.GetNestedItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/log/nested/{parentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"parentId"+"}", url.PathEscape(parameterValueToString(r.parentId, "parentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.params == nil {
		return localVarReturnValue, nil, reportError("params is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	if r.filterEqItem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.item", r.filterEqItem, "form", "")
	}
	if r.filterEqLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.level", r.filterEqLevel, "form", "")
	}
	if r.filterEqMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.message", r.filterEqMessage, "form", "")
	}
	if r.filterEqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.id", r.filterEqId, "form", "")
	}
	if r.filterEqPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.path", r.filterEqPath, "form", "")
	}
	if r.filterEqAutoAnalyzed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.autoAnalyzed", r.filterEqAutoAnalyzed, "form", "")
	}
	if r.filterEqLaunchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.launchId", r.filterEqLaunchId, "form", "")
	}
	if r.filterEqLaunch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.launch", r.filterEqLaunch, "form", "")
	}
	if r.filterEqStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.status", r.filterEqStatus, "form", "")
	}
	if r.filterEqRetryParentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.retryParentId", r.filterEqRetryParentId, "form", "")
	}
	if r.filterEqLogId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.logId", r.filterEqLogId, "form", "")
	}
	if r.filterEqLastModified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.lastModified", r.filterEqLastModified, "form", "")
	}
	if r.filterEqBinaryContent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.binaryContent", r.filterEqBinaryContent, "form", "")
	}
	if r.filterEqLogTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.logTime", r.filterEqLogTime, "form", "")
	}
	if r.filterEqProjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.projectId", r.filterEqProjectId, "form", "")
	}
	if r.filterEqRetryParentLaunchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.retryParentLaunchId", r.filterEqRetryParentLaunchId, "form", "")
	}
	if r.pagePage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.page", r.pagePage, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.sort", r.pageSort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPageNumberRequest struct {
	ctx                         context.Context
	ApiService                  *LogAPIService
	logId                       int64
	projectName                 string
	filterEqItem                *int32
	filterEqLevel               *string
	filterEqMessage             *string
	filterEqId                  *int32
	filterEqPath                *string
	filterEqAutoAnalyzed        *bool
	filterEqLaunchId            *int32
	filterEqLaunch              *int32
	filterEqStatus              *string
	filterEqRetryParentId       *int32
	filterEqLogId               *int32
	filterEqLastModified        *string
	filterEqBinaryContent       *string
	filterEqLogTime             *string
	filterEqProjectId           *int32
	filterEqRetryParentLaunchId *int32
	pagePage                    *int32
	pageSize                    *int32
	pageSort                    *string
}

// Filters by &#39;item&#39;
func (r ApiGetPageNumberRequest) FilterEqItem(filterEqItem int32) ApiGetPageNumberRequest {
	r.filterEqItem = &filterEqItem
	return r
}

// Filters by &#39;level&#39;
func (r ApiGetPageNumberRequest) FilterEqLevel(filterEqLevel string) ApiGetPageNumberRequest {
	r.filterEqLevel = &filterEqLevel
	return r
}

// Filters by &#39;message&#39;
func (r ApiGetPageNumberRequest) FilterEqMessage(filterEqMessage string) ApiGetPageNumberRequest {
	r.filterEqMessage = &filterEqMessage
	return r
}

// Filters by &#39;id&#39;
func (r ApiGetPageNumberRequest) FilterEqId(filterEqId int32) ApiGetPageNumberRequest {
	r.filterEqId = &filterEqId
	return r
}

// Filters by &#39;path&#39;
func (r ApiGetPageNumberRequest) FilterEqPath(filterEqPath string) ApiGetPageNumberRequest {
	r.filterEqPath = &filterEqPath
	return r
}

// Filters by &#39;autoAnalyzed&#39;
func (r ApiGetPageNumberRequest) FilterEqAutoAnalyzed(filterEqAutoAnalyzed bool) ApiGetPageNumberRequest {
	r.filterEqAutoAnalyzed = &filterEqAutoAnalyzed
	return r
}

// Filters by &#39;launchId&#39;
func (r ApiGetPageNumberRequest) FilterEqLaunchId(filterEqLaunchId int32) ApiGetPageNumberRequest {
	r.filterEqLaunchId = &filterEqLaunchId
	return r
}

// Filters by &#39;launch&#39;
func (r ApiGetPageNumberRequest) FilterEqLaunch(filterEqLaunch int32) ApiGetPageNumberRequest {
	r.filterEqLaunch = &filterEqLaunch
	return r
}

// Filters by &#39;status&#39;
func (r ApiGetPageNumberRequest) FilterEqStatus(filterEqStatus string) ApiGetPageNumberRequest {
	r.filterEqStatus = &filterEqStatus
	return r
}

// Filters by &#39;retryParentId&#39;
func (r ApiGetPageNumberRequest) FilterEqRetryParentId(filterEqRetryParentId int32) ApiGetPageNumberRequest {
	r.filterEqRetryParentId = &filterEqRetryParentId
	return r
}

// Filters by &#39;logId&#39;
func (r ApiGetPageNumberRequest) FilterEqLogId(filterEqLogId int32) ApiGetPageNumberRequest {
	r.filterEqLogId = &filterEqLogId
	return r
}

// Filters by &#39;lastModified&#39;
func (r ApiGetPageNumberRequest) FilterEqLastModified(filterEqLastModified string) ApiGetPageNumberRequest {
	r.filterEqLastModified = &filterEqLastModified
	return r
}

// Filters by &#39;binaryContent&#39;
func (r ApiGetPageNumberRequest) FilterEqBinaryContent(filterEqBinaryContent string) ApiGetPageNumberRequest {
	r.filterEqBinaryContent = &filterEqBinaryContent
	return r
}

// Filters by &#39;logTime&#39;
func (r ApiGetPageNumberRequest) FilterEqLogTime(filterEqLogTime string) ApiGetPageNumberRequest {
	r.filterEqLogTime = &filterEqLogTime
	return r
}

// Filters by &#39;projectId&#39;
func (r ApiGetPageNumberRequest) FilterEqProjectId(filterEqProjectId int32) ApiGetPageNumberRequest {
	r.filterEqProjectId = &filterEqProjectId
	return r
}

// Filters by &#39;retryParentLaunchId&#39;
func (r ApiGetPageNumberRequest) FilterEqRetryParentLaunchId(filterEqRetryParentLaunchId int32) ApiGetPageNumberRequest {
	r.filterEqRetryParentLaunchId = &filterEqRetryParentLaunchId
	return r
}

// Results page you want to retrieve (0..N)
func (r ApiGetPageNumberRequest) PagePage(pagePage int32) ApiGetPageNumberRequest {
	r.pagePage = &pagePage
	return r
}

// Number of records per page
func (r ApiGetPageNumberRequest) PageSize(pageSize int32) ApiGetPageNumberRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetPageNumberRequest) PageSort(pageSort string) ApiGetPageNumberRequest {
	r.pageSort = &pageSort
	return r
}

func (r ApiGetPageNumberRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPageNumberExecute(r)
}

/*
GetPageNumber Get logs by filter

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param logId
	@param projectName
	@return ApiGetPageNumberRequest
*/
func (a *LogAPIService) GetPageNumber(ctx context.Context, logId int64, projectName string) ApiGetPageNumberRequest {
	return ApiGetPageNumberRequest{
		ApiService:  a,
		ctx:         ctx,
		logId:       logId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *LogAPIService) GetPageNumberExecute(r ApiGetPageNumberRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogAPIService.GetPageNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/log/{logId}/page"
	localVarPath = strings.Replace(localVarPath, "{"+"logId"+"}", url.PathEscape(parameterValueToString(r.logId, "logId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterEqItem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.item", r.filterEqItem, "form", "")
	}
	if r.filterEqLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.level", r.filterEqLevel, "form", "")
	}
	if r.filterEqMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.message", r.filterEqMessage, "form", "")
	}
	if r.filterEqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.id", r.filterEqId, "form", "")
	}
	if r.filterEqPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.path", r.filterEqPath, "form", "")
	}
	if r.filterEqAutoAnalyzed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.autoAnalyzed", r.filterEqAutoAnalyzed, "form", "")
	}
	if r.filterEqLaunchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.launchId", r.filterEqLaunchId, "form", "")
	}
	if r.filterEqLaunch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.launch", r.filterEqLaunch, "form", "")
	}
	if r.filterEqStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.status", r.filterEqStatus, "form", "")
	}
	if r.filterEqRetryParentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.retryParentId", r.filterEqRetryParentId, "form", "")
	}
	if r.filterEqLogId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.logId", r.filterEqLogId, "form", "")
	}
	if r.filterEqLastModified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.lastModified", r.filterEqLastModified, "form", "")
	}
	if r.filterEqBinaryContent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.binaryContent", r.filterEqBinaryContent, "form", "")
	}
	if r.filterEqLogTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.logTime", r.filterEqLogTime, "form", "")
	}
	if r.filterEqProjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.projectId", r.filterEqProjectId, "form", "")
	}
	if r.filterEqRetryParentLaunchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.retryParentLaunchId", r.filterEqRetryParentLaunchId, "form", "")
	}
	if r.pagePage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.page", r.pagePage, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.sort", r.pageSort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchLogsRequest struct {
	ctx         context.Context
	ApiService  *LogAPIService
	itemId      int64
	projectName string
	searchLogRq *SearchLogRq
}

func (r ApiSearchLogsRequest) SearchLogRq(searchLogRq SearchLogRq) ApiSearchLogsRequest {
	r.searchLogRq = &searchLogRq
	return r
}

func (r ApiSearchLogsRequest) Execute() ([]SearchLogRs, *http.Response, error) {
	return r.ApiService.SearchLogsExecute(r)
}

/*
SearchLogs Search test items with similar error logs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId
	@param projectName
	@return ApiSearchLogsRequest
*/
func (a *LogAPIService) SearchLogs(ctx context.Context, itemId int64, projectName string) ApiSearchLogsRequest {
	return ApiSearchLogsRequest{
		ApiService:  a,
		ctx:         ctx,
		itemId:      itemId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []SearchLogRs
func (a *LogAPIService) SearchLogsExecute(r ApiSearchLogsRequest) ([]SearchLogRs, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []SearchLogRs
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogAPIService.SearchLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/log/search/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.searchLogRq == nil {
		return localVarReturnValue, nil, reportError("searchLogRq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.searchLogRq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if a.client.cfg.ResponseMiddleware != nil {
		err = a.client.cfg.ResponseMiddleware(localVarHTTPResponse, localVarBody)
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
