/*
ReportPortal

ReportPortal API documentation

API version: develop-322
Contact: support@reportportal.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// ProjectAPIService ProjectAPI service
type ProjectAPIService service

type ApiAddUserPreferenceRequest struct {
	ctx         context.Context
	ApiService  *ProjectAPIService
	filterId    int64
	projectName string
}

func (r ApiAddUserPreferenceRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.AddUserPreferenceExecute(r)
}

/*
AddUserPreference Edit logged-in user preferences

Only for logged-in user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param filterId
	@param projectName
	@return ApiAddUserPreferenceRequest
*/
func (a *ProjectAPIService) AddUserPreference(ctx context.Context, filterId int64, projectName string) ApiAddUserPreferenceRequest {
	return ApiAddUserPreferenceRequest{
		ApiService:  a,
		ctx:         ctx,
		filterId:    filterId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *ProjectAPIService) AddUserPreferenceExecute(r ApiAddUserPreferenceRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.AddUserPreference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/{projectName}/preference/{filterId}"
	localVarPath = strings.Replace(localVarPath, "{"+"filterId"+"}", url.PathEscape(parameterValueToString(r.filterId, "filterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssignProjectUsersRequest struct {
	ctx           context.Context
	ApiService    *ProjectAPIService
	projectName   string
	assignUsersRQ *AssignUsersRQ
}

func (r ApiAssignProjectUsersRequest) AssignUsersRQ(assignUsersRQ AssignUsersRQ) ApiAssignProjectUsersRequest {
	r.assignUsersRQ = &assignUsersRQ
	return r
}

func (r ApiAssignProjectUsersRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.AssignProjectUsersExecute(r)
}

/*
AssignProjectUsers Assign users

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiAssignProjectUsersRequest
*/
func (a *ProjectAPIService) AssignProjectUsers(ctx context.Context, projectName string) ApiAssignProjectUsersRequest {
	return ApiAssignProjectUsersRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *ProjectAPIService) AssignProjectUsersExecute(r ApiAssignProjectUsersRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.AssignProjectUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/{projectName}/assign"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assignUsersRQ == nil {
		return localVarReturnValue, nil, reportError("assignUsersRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.assignUsersRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateProjectRequest struct {
	ctx             context.Context
	ApiService      *ProjectAPIService
	createProjectRQ *CreateProjectRQ
}

func (r ApiCreateProjectRequest) CreateProjectRQ(createProjectRQ CreateProjectRQ) ApiCreateProjectRequest {
	r.createProjectRQ = &createProjectRQ
	return r
}

func (r ApiCreateProjectRequest) Execute() (*EntryCreatedRS, *http.Response, error) {
	return r.ApiService.CreateProjectExecute(r)
}

/*
CreateProject Create new project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateProjectRequest
*/
func (a *ProjectAPIService) CreateProject(ctx context.Context) ApiCreateProjectRequest {
	return ApiCreateProjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return EntryCreatedRS
func (a *ProjectAPIService) CreateProjectExecute(r ApiCreateProjectRequest) (*EntryCreatedRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EntryCreatedRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.CreateProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createProjectRQ == nil {
		return localVarReturnValue, nil, reportError("createProjectRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createProjectRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteProjectRequest struct {
	ctx        context.Context
	ApiService *ProjectAPIService
	ids        *[]int64
}

func (r ApiDeleteProjectRequest) Ids(ids []int64) ApiDeleteProjectRequest {
	r.ids = &ids
	return r
}

func (r ApiDeleteProjectRequest) Execute() (*DeleteBulkRS, *http.Response, error) {
	return r.ApiService.DeleteProjectExecute(r)
}

/*
DeleteProject Delete multiple projects

Could be deleted only by users with administrator role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteProjectRequest
*/
func (a *ProjectAPIService) DeleteProject(ctx context.Context) ApiDeleteProjectRequest {
	return ApiDeleteProjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DeleteBulkRS
func (a *ProjectAPIService) DeleteProjectExecute(r ApiDeleteProjectRequest) (*DeleteBulkRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeleteBulkRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.DeleteProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	{
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteProject1Request struct {
	ctx        context.Context
	ApiService *ProjectAPIService
	projectId  int64
}

func (r ApiDeleteProject1Request) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.DeleteProject1Execute(r)
}

/*
DeleteProject1 Delete project

Could be deleted only by users with administrator role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId
	@return ApiDeleteProject1Request
*/
func (a *ProjectAPIService) DeleteProject1(ctx context.Context, projectId int64) ApiDeleteProject1Request {
	return ApiDeleteProject1Request{
		ApiService: a,
		ctx:        ctx,
		projectId:  projectId,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *ProjectAPIService) DeleteProject1Execute(r ApiDeleteProject1Request) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.DeleteProject1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/{projectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteProjectIndexRequest struct {
	ctx         context.Context
	ApiService  *ProjectAPIService
	projectName string
}

func (r ApiDeleteProjectIndexRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.DeleteProjectIndexExecute(r)
}

/*
DeleteProjectIndex Delete project index from ML

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiDeleteProjectIndexRequest
*/
func (a *ProjectAPIService) DeleteProjectIndex(ctx context.Context, projectName string) ApiDeleteProjectIndexRequest {
	return ApiDeleteProjectIndexRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *ProjectAPIService) DeleteProjectIndexExecute(r ApiDeleteProjectIndexRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.DeleteProjectIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/{projectName}/index"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportProjectsRequest struct {
	ctx                      context.Context
	ApiService               *ProjectAPIService
	view                     *string
	filterEqCreationDate     *string
	filterEqUsersQuantity    *int32
	filterEqId               *int32
	filterEqName             *string
	filterEqOrganization     *string
	filterEqLaunchesQuantity *int32
	filterEqType             *string
	filterEqLastRun          *string
}

func (r ApiExportProjectsRequest) View(view string) ApiExportProjectsRequest {
	r.view = &view
	return r
}

// Filters by &#39;creationDate&#39;
func (r ApiExportProjectsRequest) FilterEqCreationDate(filterEqCreationDate string) ApiExportProjectsRequest {
	r.filterEqCreationDate = &filterEqCreationDate
	return r
}

// Filters by &#39;usersQuantity&#39;
func (r ApiExportProjectsRequest) FilterEqUsersQuantity(filterEqUsersQuantity int32) ApiExportProjectsRequest {
	r.filterEqUsersQuantity = &filterEqUsersQuantity
	return r
}

// Filters by &#39;id&#39;
func (r ApiExportProjectsRequest) FilterEqId(filterEqId int32) ApiExportProjectsRequest {
	r.filterEqId = &filterEqId
	return r
}

// Filters by &#39;name&#39;
func (r ApiExportProjectsRequest) FilterEqName(filterEqName string) ApiExportProjectsRequest {
	r.filterEqName = &filterEqName
	return r
}

// Filters by &#39;organization&#39;
func (r ApiExportProjectsRequest) FilterEqOrganization(filterEqOrganization string) ApiExportProjectsRequest {
	r.filterEqOrganization = &filterEqOrganization
	return r
}

// Filters by &#39;launchesQuantity&#39;
func (r ApiExportProjectsRequest) FilterEqLaunchesQuantity(filterEqLaunchesQuantity int32) ApiExportProjectsRequest {
	r.filterEqLaunchesQuantity = &filterEqLaunchesQuantity
	return r
}

// Filters by &#39;type&#39;
func (r ApiExportProjectsRequest) FilterEqType(filterEqType string) ApiExportProjectsRequest {
	r.filterEqType = &filterEqType
	return r
}

// Filters by &#39;lastRun&#39;
func (r ApiExportProjectsRequest) FilterEqLastRun(filterEqLastRun string) ApiExportProjectsRequest {
	r.filterEqLastRun = &filterEqLastRun
	return r
}

func (r ApiExportProjectsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExportProjectsExecute(r)
}

/*
ExportProjects Exports information about all projects

Allowable only for users with administrator role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiExportProjectsRequest
*/
func (a *ProjectAPIService) ExportProjects(ctx context.Context) ApiExportProjectsRequest {
	return ApiExportProjectsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ExportProjectsExecute(r ApiExportProjectsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ExportProjects")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.view != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view", r.view, "form", "")
	}
	if r.filterEqCreationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.creationDate", r.filterEqCreationDate, "form", "")
	}
	if r.filterEqUsersQuantity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.usersQuantity", r.filterEqUsersQuantity, "form", "")
	}
	if r.filterEqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.id", r.filterEqId, "form", "")
	}
	if r.filterEqName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.name", r.filterEqName, "form", "")
	}
	if r.filterEqOrganization != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.organization", r.filterEqOrganization, "form", "")
	}
	if r.filterEqLaunchesQuantity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.launchesQuantity", r.filterEqLaunchesQuantity, "form", "")
	}
	if r.filterEqType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.type", r.filterEqType, "form", "")
	}
	if r.filterEqLastRun != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.lastRun", r.filterEqLastRun, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllProjectNamesRequest struct {
	ctx        context.Context
	ApiService *ProjectAPIService
}

func (r ApiGetAllProjectNamesRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetAllProjectNamesExecute(r)
}

/*
GetAllProjectNames Get All Project Names

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAllProjectNamesRequest
*/
func (a *ProjectAPIService) GetAllProjectNames(ctx context.Context) ApiGetAllProjectNamesRequest {
	return ApiGetAllProjectNamesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []string
func (a *ProjectAPIService) GetAllProjectNamesExecute(r ApiGetAllProjectNamesRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetAllProjectNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/names"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllProjectsInfoRequest struct {
	ctx                      context.Context
	ApiService               *ProjectAPIService
	filterEqCreationDate     *string
	filterEqUsersQuantity    *int32
	filterEqId               *int32
	filterEqName             *string
	filterEqOrganization     *string
	filterEqLaunchesQuantity *int32
	filterEqType             *string
	filterEqLastRun          *string
	pagePage                 *int32
	pageSize                 *int32
	pageSort                 *string
}

// Filters by &#39;creationDate&#39;
func (r ApiGetAllProjectsInfoRequest) FilterEqCreationDate(filterEqCreationDate string) ApiGetAllProjectsInfoRequest {
	r.filterEqCreationDate = &filterEqCreationDate
	return r
}

// Filters by &#39;usersQuantity&#39;
func (r ApiGetAllProjectsInfoRequest) FilterEqUsersQuantity(filterEqUsersQuantity int32) ApiGetAllProjectsInfoRequest {
	r.filterEqUsersQuantity = &filterEqUsersQuantity
	return r
}

// Filters by &#39;id&#39;
func (r ApiGetAllProjectsInfoRequest) FilterEqId(filterEqId int32) ApiGetAllProjectsInfoRequest {
	r.filterEqId = &filterEqId
	return r
}

// Filters by &#39;name&#39;
func (r ApiGetAllProjectsInfoRequest) FilterEqName(filterEqName string) ApiGetAllProjectsInfoRequest {
	r.filterEqName = &filterEqName
	return r
}

// Filters by &#39;organization&#39;
func (r ApiGetAllProjectsInfoRequest) FilterEqOrganization(filterEqOrganization string) ApiGetAllProjectsInfoRequest {
	r.filterEqOrganization = &filterEqOrganization
	return r
}

// Filters by &#39;launchesQuantity&#39;
func (r ApiGetAllProjectsInfoRequest) FilterEqLaunchesQuantity(filterEqLaunchesQuantity int32) ApiGetAllProjectsInfoRequest {
	r.filterEqLaunchesQuantity = &filterEqLaunchesQuantity
	return r
}

// Filters by &#39;type&#39;
func (r ApiGetAllProjectsInfoRequest) FilterEqType(filterEqType string) ApiGetAllProjectsInfoRequest {
	r.filterEqType = &filterEqType
	return r
}

// Filters by &#39;lastRun&#39;
func (r ApiGetAllProjectsInfoRequest) FilterEqLastRun(filterEqLastRun string) ApiGetAllProjectsInfoRequest {
	r.filterEqLastRun = &filterEqLastRun
	return r
}

// Results page you want to retrieve (0..N)
func (r ApiGetAllProjectsInfoRequest) PagePage(pagePage int32) ApiGetAllProjectsInfoRequest {
	r.pagePage = &pagePage
	return r
}

// Number of records per page
func (r ApiGetAllProjectsInfoRequest) PageSize(pageSize int32) ApiGetAllProjectsInfoRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetAllProjectsInfoRequest) PageSort(pageSort string) ApiGetAllProjectsInfoRequest {
	r.pageSort = &pageSort
	return r
}

func (r ApiGetAllProjectsInfoRequest) Execute() (*PageProjectInfoResource, *http.Response, error) {
	return r.ApiService.GetAllProjectsInfoExecute(r)
}

/*
GetAllProjectsInfo Get All Projects Info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAllProjectsInfoRequest
*/
func (a *ProjectAPIService) GetAllProjectsInfo(ctx context.Context) ApiGetAllProjectsInfoRequest {
	return ApiGetAllProjectsInfoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PageProjectInfoResource
func (a *ProjectAPIService) GetAllProjectsInfoExecute(r ApiGetAllProjectsInfoRequest) (*PageProjectInfoResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageProjectInfoResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetAllProjectsInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterEqCreationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.creationDate", r.filterEqCreationDate, "form", "")
	}
	if r.filterEqUsersQuantity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.usersQuantity", r.filterEqUsersQuantity, "form", "")
	}
	if r.filterEqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.id", r.filterEqId, "form", "")
	}
	if r.filterEqName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.name", r.filterEqName, "form", "")
	}
	if r.filterEqOrganization != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.organization", r.filterEqOrganization, "form", "")
	}
	if r.filterEqLaunchesQuantity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.launchesQuantity", r.filterEqLaunchesQuantity, "form", "")
	}
	if r.filterEqType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.type", r.filterEqType, "form", "")
	}
	if r.filterEqLastRun != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.lastRun", r.filterEqLastRun, "form", "")
	}
	if r.pagePage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.page", r.pagePage, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.sort", r.pageSort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAnalyzerIndexingStatusRequest struct {
	ctx        context.Context
	ApiService *ProjectAPIService
}

func (r ApiGetAnalyzerIndexingStatusRequest) Execute() (map[string]bool, *http.Response, error) {
	return r.ApiService.GetAnalyzerIndexingStatusExecute(r)
}

/*
GetAnalyzerIndexingStatus Get Analyzer Indexing Status

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAnalyzerIndexingStatusRequest
*/
func (a *ProjectAPIService) GetAnalyzerIndexingStatus(ctx context.Context) ApiGetAnalyzerIndexingStatusRequest {
	return ApiGetAnalyzerIndexingStatusRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]bool
func (a *ProjectAPIService) GetAnalyzerIndexingStatusExecute(r ApiGetAnalyzerIndexingStatusRequest) (map[string]bool, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetAnalyzerIndexingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/analyzer/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectRequest struct {
	ctx         context.Context
	ApiService  *ProjectAPIService
	projectName string
}

func (r ApiGetProjectRequest) Execute() (*ProjectResource, *http.Response, error) {
	return r.ApiService.GetProjectExecute(r)
}

/*
GetProject Get information about project

Only for users that are assigned to the project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetProjectRequest
*/
func (a *ProjectAPIService) GetProject(ctx context.Context, projectName string) ApiGetProjectRequest {
	return ApiGetProjectRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return ProjectResource
func (a *ProjectAPIService) GetProjectExecute(r ApiGetProjectRequest) (*ProjectResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProjectResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/{projectName}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectInfoRequest struct {
	ctx         context.Context
	ApiService  *ProjectAPIService
	projectName string
	interval    *string
}

func (r ApiGetProjectInfoRequest) Interval(interval string) ApiGetProjectInfoRequest {
	r.interval = &interval
	return r
}

func (r ApiGetProjectInfoRequest) Execute() (*ProjectInfoResource, *http.Response, error) {
	return r.ApiService.GetProjectInfoExecute(r)
}

/*
GetProjectInfo Get Project Info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetProjectInfoRequest
*/
func (a *ProjectAPIService) GetProjectInfo(ctx context.Context, projectName string) ApiGetProjectInfoRequest {
	return ApiGetProjectInfoRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return ProjectInfoResource
func (a *ProjectAPIService) GetProjectInfoExecute(r ApiGetProjectInfoRequest) (*ProjectInfoResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProjectInfoResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetProjectInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/list/{projectName}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	} else {
		var defaultValue string = "3M"
		r.interval = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectUsersRequest struct {
	ctx                         context.Context
	ApiService                  *ProjectAPIService
	projectName                 string
	filterEqFullName            *string
	filterEqUuid                *string
	filterEqEmail               *string
	filterEqId                  *int32
	filterEqRole                *string
	filterEqSynchronizationDate *int32
	filterEqExpired             *bool
	filterEqProject             *[]interface{}
	filterEqType                *string
	filterEqUser                *string
	filterEqActive              *bool
	filterEqLastLogin           *int32
	filterEqExternalId          *string
	filterEqProjectId           *int32
	pagePage                    *int32
	pageSize                    *int32
	pageSort                    *string
}

// Filters by &#39;fullName&#39;
func (r ApiGetProjectUsersRequest) FilterEqFullName(filterEqFullName string) ApiGetProjectUsersRequest {
	r.filterEqFullName = &filterEqFullName
	return r
}

// Filters by &#39;uuid&#39;
func (r ApiGetProjectUsersRequest) FilterEqUuid(filterEqUuid string) ApiGetProjectUsersRequest {
	r.filterEqUuid = &filterEqUuid
	return r
}

// Filters by &#39;email&#39;
func (r ApiGetProjectUsersRequest) FilterEqEmail(filterEqEmail string) ApiGetProjectUsersRequest {
	r.filterEqEmail = &filterEqEmail
	return r
}

// Filters by &#39;id&#39;
func (r ApiGetProjectUsersRequest) FilterEqId(filterEqId int32) ApiGetProjectUsersRequest {
	r.filterEqId = &filterEqId
	return r
}

// Filters by &#39;role&#39;
func (r ApiGetProjectUsersRequest) FilterEqRole(filterEqRole string) ApiGetProjectUsersRequest {
	r.filterEqRole = &filterEqRole
	return r
}

// Filters by &#39;synchronizationDate&#39;
func (r ApiGetProjectUsersRequest) FilterEqSynchronizationDate(filterEqSynchronizationDate int32) ApiGetProjectUsersRequest {
	r.filterEqSynchronizationDate = &filterEqSynchronizationDate
	return r
}

// Filters by &#39;expired&#39;
func (r ApiGetProjectUsersRequest) FilterEqExpired(filterEqExpired bool) ApiGetProjectUsersRequest {
	r.filterEqExpired = &filterEqExpired
	return r
}

// Filters by &#39;project&#39;
func (r ApiGetProjectUsersRequest) FilterEqProject(filterEqProject []interface{}) ApiGetProjectUsersRequest {
	r.filterEqProject = &filterEqProject
	return r
}

// Filters by &#39;type&#39;
func (r ApiGetProjectUsersRequest) FilterEqType(filterEqType string) ApiGetProjectUsersRequest {
	r.filterEqType = &filterEqType
	return r
}

// Filters by &#39;user&#39;
func (r ApiGetProjectUsersRequest) FilterEqUser(filterEqUser string) ApiGetProjectUsersRequest {
	r.filterEqUser = &filterEqUser
	return r
}

// Filters by &#39;active&#39;
func (r ApiGetProjectUsersRequest) FilterEqActive(filterEqActive bool) ApiGetProjectUsersRequest {
	r.filterEqActive = &filterEqActive
	return r
}

// Filters by &#39;lastLogin&#39;
func (r ApiGetProjectUsersRequest) FilterEqLastLogin(filterEqLastLogin int32) ApiGetProjectUsersRequest {
	r.filterEqLastLogin = &filterEqLastLogin
	return r
}

// Filters by &#39;externalId&#39;
func (r ApiGetProjectUsersRequest) FilterEqExternalId(filterEqExternalId string) ApiGetProjectUsersRequest {
	r.filterEqExternalId = &filterEqExternalId
	return r
}

// Filters by &#39;projectId&#39;
func (r ApiGetProjectUsersRequest) FilterEqProjectId(filterEqProjectId int32) ApiGetProjectUsersRequest {
	r.filterEqProjectId = &filterEqProjectId
	return r
}

// Results page you want to retrieve (0..N)
func (r ApiGetProjectUsersRequest) PagePage(pagePage int32) ApiGetProjectUsersRequest {
	r.pagePage = &pagePage
	return r
}

// Number of records per page
func (r ApiGetProjectUsersRequest) PageSize(pageSize int32) ApiGetProjectUsersRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetProjectUsersRequest) PageSort(pageSort string) ApiGetProjectUsersRequest {
	r.pageSort = &pageSort
	return r
}

func (r ApiGetProjectUsersRequest) Execute() (*PageUserResource, *http.Response, error) {
	return r.ApiService.GetProjectUsersExecute(r)
}

/*
GetProjectUsers Get users assigned on current project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetProjectUsersRequest
*/
func (a *ProjectAPIService) GetProjectUsers(ctx context.Context, projectName string) ApiGetProjectUsersRequest {
	return ApiGetProjectUsersRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return PageUserResource
func (a *ProjectAPIService) GetProjectUsersExecute(r ApiGetProjectUsersRequest) (*PageUserResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageUserResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetProjectUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/{projectName}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterEqFullName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.fullName", r.filterEqFullName, "form", "")
	}
	if r.filterEqUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.uuid", r.filterEqUuid, "form", "")
	}
	if r.filterEqEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.email", r.filterEqEmail, "form", "")
	}
	if r.filterEqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.id", r.filterEqId, "form", "")
	}
	if r.filterEqRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.role", r.filterEqRole, "form", "")
	}
	if r.filterEqSynchronizationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.synchronizationDate", r.filterEqSynchronizationDate, "form", "")
	}
	if r.filterEqExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.expired", r.filterEqExpired, "form", "")
	}
	if r.filterEqProject != nil {
		t := *r.filterEqProject
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.project", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.project", t, "form", "multi")
		}
	}
	if r.filterEqType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.type", r.filterEqType, "form", "")
	}
	if r.filterEqUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.user", r.filterEqUser, "form", "")
	}
	if r.filterEqActive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.active", r.filterEqActive, "form", "")
	}
	if r.filterEqLastLogin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.lastLogin", r.filterEqLastLogin, "form", "")
	}
	if r.filterEqExternalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.externalId", r.filterEqExternalId, "form", "")
	}
	if r.filterEqProjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.projectId", r.filterEqProjectId, "form", "")
	}
	if r.pagePage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.page", r.pagePage, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.sort", r.pageSort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectUsers1Request struct {
	ctx            context.Context
	ApiService     *ProjectAPIService
	filterCntUsers *string
	projectName    string
}

func (r ApiGetProjectUsers1Request) FilterCntUsers(filterCntUsers string) ApiGetProjectUsers1Request {
	r.filterCntUsers = &filterCntUsers
	return r
}

func (r ApiGetProjectUsers1Request) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetProjectUsers1Execute(r)
}

/*
GetProjectUsers1 Load project users by filter

Only for users that are members of the project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetProjectUsers1Request
*/
func (a *ProjectAPIService) GetProjectUsers1(ctx context.Context, projectName string) ApiGetProjectUsers1Request {
	return ApiGetProjectUsers1Request{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []string
func (a *ProjectAPIService) GetProjectUsers1Execute(r ApiGetProjectUsers1Request) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetProjectUsers1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/{projectName}/usernames"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.filterCntUsers == nil {
		return localVarReturnValue, nil, reportError("filterCntUsers is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "filter.cnt.users", r.filterCntUsers, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectWidgetRequest struct {
	ctx         context.Context
	ApiService  *ProjectAPIService
	projectName string
	widgetCode  string
	interval    *string
}

func (r ApiGetProjectWidgetRequest) Interval(interval string) ApiGetProjectWidgetRequest {
	r.interval = &interval
	return r
}

func (r ApiGetProjectWidgetRequest) Execute() (map[string]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetProjectWidgetExecute(r)
}

/*
GetProjectWidget Get Project Widget

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@param widgetCode
	@return ApiGetProjectWidgetRequest
*/
func (a *ProjectAPIService) GetProjectWidget(ctx context.Context, projectName, widgetCode string) ApiGetProjectWidgetRequest {
	return ApiGetProjectWidgetRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
		widgetCode:  widgetCode,
	}
}

// Execute executes the request
//
//	@return map[string]map[string]interface{}
func (a *ProjectAPIService) GetProjectWidgetExecute(r ApiGetProjectWidgetRequest) (map[string]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetProjectWidget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/{projectName}/widget/{widgetCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"widgetCode"+"}", url.PathEscape(parameterValueToString(r.widgetCode, "widgetCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "form", "")
	} else {
		var defaultValue string = "3M"
		r.interval = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserPreferenceRequest struct {
	ctx         context.Context
	ApiService  *ProjectAPIService
	projectName string
}

func (r ApiGetUserPreferenceRequest) Execute() (*PreferenceResource, *http.Response, error) {
	return r.ApiService.GetUserPreferenceExecute(r)
}

/*
GetUserPreference Load logged-in user preferences

Only for logged-in user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetUserPreferenceRequest
*/
func (a *ProjectAPIService) GetUserPreference(ctx context.Context, projectName string) ApiGetUserPreferenceRequest {
	return ApiGetUserPreferenceRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return PreferenceResource
func (a *ProjectAPIService) GetUserPreferenceExecute(r ApiGetUserPreferenceRequest) (*PreferenceResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PreferenceResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetUserPreference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/{projectName}/preference"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserPreference1Request struct {
	ctx         context.Context
	ApiService  *ProjectAPIService
	projectName string
}

func (r ApiGetUserPreference1Request) Execute() (*PreferenceResource, *http.Response, error) {
	return r.ApiService.GetUserPreference1Execute(r)
}

/*
GetUserPreference1 Load logged-in user preferences

Only for logged-in user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetUserPreference1Request
*/
func (a *ProjectAPIService) GetUserPreference1(ctx context.Context, projectName string) ApiGetUserPreference1Request {
	return ApiGetUserPreference1Request{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return PreferenceResource
func (a *ProjectAPIService) GetUserPreference1Execute(r ApiGetUserPreference1Request) (*PreferenceResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PreferenceResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetUserPreference1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/{projectName}/preference/"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsersForAssignRequest struct {
	ctx                         context.Context
	ApiService                  *ProjectAPIService
	projectName                 string
	filterEqFullName            *string
	filterEqUuid                *string
	filterEqEmail               *string
	filterEqId                  *int32
	filterEqRole                *string
	filterEqSynchronizationDate *int32
	filterEqExpired             *bool
	filterEqProject             *[]interface{}
	filterEqType                *string
	filterEqUser                *string
	filterEqActive              *bool
	filterEqLastLogin           *int32
	filterEqExternalId          *string
	filterEqProjectId           *int32
	pagePage                    *int32
	pageSize                    *int32
	pageSort                    *string
}

// Filters by &#39;fullName&#39;
func (r ApiGetUsersForAssignRequest) FilterEqFullName(filterEqFullName string) ApiGetUsersForAssignRequest {
	r.filterEqFullName = &filterEqFullName
	return r
}

// Filters by &#39;uuid&#39;
func (r ApiGetUsersForAssignRequest) FilterEqUuid(filterEqUuid string) ApiGetUsersForAssignRequest {
	r.filterEqUuid = &filterEqUuid
	return r
}

// Filters by &#39;email&#39;
func (r ApiGetUsersForAssignRequest) FilterEqEmail(filterEqEmail string) ApiGetUsersForAssignRequest {
	r.filterEqEmail = &filterEqEmail
	return r
}

// Filters by &#39;id&#39;
func (r ApiGetUsersForAssignRequest) FilterEqId(filterEqId int32) ApiGetUsersForAssignRequest {
	r.filterEqId = &filterEqId
	return r
}

// Filters by &#39;role&#39;
func (r ApiGetUsersForAssignRequest) FilterEqRole(filterEqRole string) ApiGetUsersForAssignRequest {
	r.filterEqRole = &filterEqRole
	return r
}

// Filters by &#39;synchronizationDate&#39;
func (r ApiGetUsersForAssignRequest) FilterEqSynchronizationDate(filterEqSynchronizationDate int32) ApiGetUsersForAssignRequest {
	r.filterEqSynchronizationDate = &filterEqSynchronizationDate
	return r
}

// Filters by &#39;expired&#39;
func (r ApiGetUsersForAssignRequest) FilterEqExpired(filterEqExpired bool) ApiGetUsersForAssignRequest {
	r.filterEqExpired = &filterEqExpired
	return r
}

// Filters by &#39;project&#39;
func (r ApiGetUsersForAssignRequest) FilterEqProject(filterEqProject []interface{}) ApiGetUsersForAssignRequest {
	r.filterEqProject = &filterEqProject
	return r
}

// Filters by &#39;type&#39;
func (r ApiGetUsersForAssignRequest) FilterEqType(filterEqType string) ApiGetUsersForAssignRequest {
	r.filterEqType = &filterEqType
	return r
}

// Filters by &#39;user&#39;
func (r ApiGetUsersForAssignRequest) FilterEqUser(filterEqUser string) ApiGetUsersForAssignRequest {
	r.filterEqUser = &filterEqUser
	return r
}

// Filters by &#39;active&#39;
func (r ApiGetUsersForAssignRequest) FilterEqActive(filterEqActive bool) ApiGetUsersForAssignRequest {
	r.filterEqActive = &filterEqActive
	return r
}

// Filters by &#39;lastLogin&#39;
func (r ApiGetUsersForAssignRequest) FilterEqLastLogin(filterEqLastLogin int32) ApiGetUsersForAssignRequest {
	r.filterEqLastLogin = &filterEqLastLogin
	return r
}

// Filters by &#39;externalId&#39;
func (r ApiGetUsersForAssignRequest) FilterEqExternalId(filterEqExternalId string) ApiGetUsersForAssignRequest {
	r.filterEqExternalId = &filterEqExternalId
	return r
}

// Filters by &#39;projectId&#39;
func (r ApiGetUsersForAssignRequest) FilterEqProjectId(filterEqProjectId int32) ApiGetUsersForAssignRequest {
	r.filterEqProjectId = &filterEqProjectId
	return r
}

// Results page you want to retrieve (0..N)
func (r ApiGetUsersForAssignRequest) PagePage(pagePage int32) ApiGetUsersForAssignRequest {
	r.pagePage = &pagePage
	return r
}

// Number of records per page
func (r ApiGetUsersForAssignRequest) PageSize(pageSize int32) ApiGetUsersForAssignRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetUsersForAssignRequest) PageSort(pageSort string) ApiGetUsersForAssignRequest {
	r.pageSort = &pageSort
	return r
}

func (r ApiGetUsersForAssignRequest) Execute() (*PageUserResource, *http.Response, error) {
	return r.ApiService.GetUsersForAssignExecute(r)
}

/*
GetUsersForAssign Load users which can be assigned to specified project

Only for users with project manager permissions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetUsersForAssignRequest
*/
func (a *ProjectAPIService) GetUsersForAssign(ctx context.Context, projectName string) ApiGetUsersForAssignRequest {
	return ApiGetUsersForAssignRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return PageUserResource
func (a *ProjectAPIService) GetUsersForAssignExecute(r ApiGetUsersForAssignRequest) (*PageUserResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageUserResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.GetUsersForAssign")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/{projectName}/assignable"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterEqFullName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.fullName", r.filterEqFullName, "form", "")
	}
	if r.filterEqUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.uuid", r.filterEqUuid, "form", "")
	}
	if r.filterEqEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.email", r.filterEqEmail, "form", "")
	}
	if r.filterEqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.id", r.filterEqId, "form", "")
	}
	if r.filterEqRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.role", r.filterEqRole, "form", "")
	}
	if r.filterEqSynchronizationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.synchronizationDate", r.filterEqSynchronizationDate, "form", "")
	}
	if r.filterEqExpired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.expired", r.filterEqExpired, "form", "")
	}
	if r.filterEqProject != nil {
		t := *r.filterEqProject
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.project", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.project", t, "form", "multi")
		}
	}
	if r.filterEqType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.type", r.filterEqType, "form", "")
	}
	if r.filterEqUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.user", r.filterEqUser, "form", "")
	}
	if r.filterEqActive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.active", r.filterEqActive, "form", "")
	}
	if r.filterEqLastLogin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.lastLogin", r.filterEqLastLogin, "form", "")
	}
	if r.filterEqExternalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.externalId", r.filterEqExternalId, "form", "")
	}
	if r.filterEqProjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.projectId", r.filterEqProjectId, "form", "")
	}
	if r.pagePage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.page", r.pagePage, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.sort", r.pageSort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIndexProjectDataRequest struct {
	ctx         context.Context
	ApiService  *ProjectAPIService
	projectName string
}

func (r ApiIndexProjectDataRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.IndexProjectDataExecute(r)
}

/*
IndexProjectData Starts reindex all project data in ML

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiIndexProjectDataRequest
*/
func (a *ProjectAPIService) IndexProjectData(ctx context.Context, projectName string) ApiIndexProjectDataRequest {
	return ApiIndexProjectDataRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *ProjectAPIService) IndexProjectDataExecute(r ApiIndexProjectDataRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.IndexProjectData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/{projectName}/index"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveUserPreferenceRequest struct {
	ctx         context.Context
	ApiService  *ProjectAPIService
	filterId    int64
	projectName string
}

func (r ApiRemoveUserPreferenceRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.RemoveUserPreferenceExecute(r)
}

/*
RemoveUserPreference Delete logged-in user preferences

Only for logged-in user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param filterId
	@param projectName
	@return ApiRemoveUserPreferenceRequest
*/
func (a *ProjectAPIService) RemoveUserPreference(ctx context.Context, filterId int64, projectName string) ApiRemoveUserPreferenceRequest {
	return ApiRemoveUserPreferenceRequest{
		ApiService:  a,
		ctx:         ctx,
		filterId:    filterId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *ProjectAPIService) RemoveUserPreferenceExecute(r ApiRemoveUserPreferenceRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.RemoveUserPreference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/{projectName}/preference/{filterId}"
	localVarPath = strings.Replace(localVarPath, "{"+"filterId"+"}", url.PathEscape(parameterValueToString(r.filterId, "filterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchForUserRequest struct {
	ctx         context.Context
	ApiService  *ProjectAPIService
	projectName string
	term        *string
	pagePage    *int32
	pageSize    *int32
	pageSort    *string
}

func (r ApiSearchForUserRequest) Term(term string) ApiSearchForUserRequest {
	r.term = &term
	return r
}

// Results page you want to retrieve (0..N)
func (r ApiSearchForUserRequest) PagePage(pagePage int32) ApiSearchForUserRequest {
	r.pagePage = &pagePage
	return r
}

// Number of records per page
func (r ApiSearchForUserRequest) PageSize(pageSize int32) ApiSearchForUserRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiSearchForUserRequest) PageSort(pageSort string) ApiSearchForUserRequest {
	r.pageSort = &pageSort
	return r
}

func (r ApiSearchForUserRequest) Execute() (*PageSearchUserResource, *http.Response, error) {
	return r.ApiService.SearchForUserExecute(r)
}

/*
SearchForUser Search For User

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiSearchForUserRequest
*/
func (a *ProjectAPIService) SearchForUser(ctx context.Context, projectName string) ApiSearchForUserRequest {
	return ApiSearchForUserRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return PageSearchUserResource
func (a *ProjectAPIService) SearchForUserExecute(r ApiSearchForUserRequest) (*PageSearchUserResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageSearchUserResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.SearchForUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/{projectName}/usernames/search"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.term == nil {
		return localVarReturnValue, nil, reportError("term is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "term", r.term, "form", "")
	if r.pagePage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.page", r.pagePage, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.sort", r.pageSort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchProjectNamesRequest struct {
	ctx        context.Context
	ApiService *ProjectAPIService
	term       *string
}

func (r ApiSearchProjectNamesRequest) Term(term string) ApiSearchProjectNamesRequest {
	r.term = &term
	return r
}

func (r ApiSearchProjectNamesRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.SearchProjectNamesExecute(r)
}

/*
SearchProjectNames Search Project Names

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSearchProjectNamesRequest
*/
func (a *ProjectAPIService) SearchProjectNames(ctx context.Context) ApiSearchProjectNamesRequest {
	return ApiSearchProjectNamesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []string
func (a *ProjectAPIService) SearchProjectNamesExecute(r ApiSearchProjectNamesRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.SearchProjectNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/names/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.term == nil {
		return localVarReturnValue, nil, reportError("term is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "term", r.term, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnassignProjectUsersRequest struct {
	ctx             context.Context
	ApiService      *ProjectAPIService
	projectName     string
	unassignUsersRQ *UnassignUsersRQ
}

func (r ApiUnassignProjectUsersRequest) UnassignUsersRQ(unassignUsersRQ UnassignUsersRQ) ApiUnassignProjectUsersRequest {
	r.unassignUsersRQ = &unassignUsersRQ
	return r
}

func (r ApiUnassignProjectUsersRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.UnassignProjectUsersExecute(r)
}

/*
UnassignProjectUsers Unassign users

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiUnassignProjectUsersRequest
*/
func (a *ProjectAPIService) UnassignProjectUsers(ctx context.Context, projectName string) ApiUnassignProjectUsersRequest {
	return ApiUnassignProjectUsersRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *ProjectAPIService) UnassignProjectUsersExecute(r ApiUnassignProjectUsersRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.UnassignProjectUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/{projectName}/unassign"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unassignUsersRQ == nil {
		return localVarReturnValue, nil, reportError("unassignUsersRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unassignUsersRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateProjectRequest struct {
	ctx             context.Context
	ApiService      *ProjectAPIService
	projectName     string
	updateProjectRQ *UpdateProjectRQ
}

func (r ApiUpdateProjectRequest) UpdateProjectRQ(updateProjectRQ UpdateProjectRQ) ApiUpdateProjectRequest {
	r.updateProjectRQ = &updateProjectRQ
	return r
}

func (r ApiUpdateProjectRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.UpdateProjectExecute(r)
}

/*
UpdateProject Update project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiUpdateProjectRequest
*/
func (a *ProjectAPIService) UpdateProject(ctx context.Context, projectName string) ApiUpdateProjectRequest {
	return ApiUpdateProjectRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *ProjectAPIService) UpdateProjectExecute(r ApiUpdateProjectRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.UpdateProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/{projectName}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateProjectRQ == nil {
		return localVarReturnValue, nil, reportError("updateProjectRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateProjectRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateProjectNotificationConfigRequest struct {
	ctx                          context.Context
	ApiService                   *ProjectAPIService
	projectName                  string
	projectNotificationConfigDTO *ProjectNotificationConfigDTO
}

func (r ApiUpdateProjectNotificationConfigRequest) ProjectNotificationConfigDTO(projectNotificationConfigDTO ProjectNotificationConfigDTO) ApiUpdateProjectNotificationConfigRequest {
	r.projectNotificationConfigDTO = &projectNotificationConfigDTO
	return r
}

func (r ApiUpdateProjectNotificationConfigRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.UpdateProjectNotificationConfigExecute(r)
}

/*
UpdateProjectNotificationConfig Update project notifications configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiUpdateProjectNotificationConfigRequest
*/
func (a *ProjectAPIService) UpdateProjectNotificationConfig(ctx context.Context, projectName string) ApiUpdateProjectNotificationConfigRequest {
	return ApiUpdateProjectNotificationConfigRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *ProjectAPIService) UpdateProjectNotificationConfigExecute(r ApiUpdateProjectNotificationConfigRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.UpdateProjectNotificationConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/project/{projectName}/notification"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.projectNotificationConfigDTO == nil {
		return localVarReturnValue, nil, reportError("projectNotificationConfigDTO is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.projectNotificationConfigDTO
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
