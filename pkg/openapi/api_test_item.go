/*
ReportPortal

ReportPortal API documentation

API version: develop-322
Contact: support@reportportal.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// TestItemAPIService TestItemAPI service
type TestItemAPIService service

type ApiBulkUpdate1Request struct {
	ctx              context.Context
	ApiService       *TestItemAPIService
	projectName      string
	bulkInfoUpdateRQ *BulkInfoUpdateRQ
}

func (r ApiBulkUpdate1Request) BulkInfoUpdateRQ(bulkInfoUpdateRQ BulkInfoUpdateRQ) ApiBulkUpdate1Request {
	r.bulkInfoUpdateRQ = &bulkInfoUpdateRQ
	return r
}

func (r ApiBulkUpdate1Request) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.BulkUpdate1Execute(r)
}

/*
BulkUpdate1 Bulk update attributes and description

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiBulkUpdate1Request
*/
func (a *TestItemAPIService) BulkUpdate1(ctx context.Context, projectName string) ApiBulkUpdate1Request {
	return ApiBulkUpdate1Request{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *TestItemAPIService) BulkUpdate1Execute(r ApiBulkUpdate1Request) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.BulkUpdate1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/info"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkInfoUpdateRQ == nil {
		return localVarReturnValue, nil, reportError("bulkInfoUpdateRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkInfoUpdateRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDefineTestItemIssueTypeRequest struct {
	ctx           context.Context
	ApiService    *TestItemAPIService
	projectName   string
	defineIssueRQ *DefineIssueRQ
}

func (r ApiDefineTestItemIssueTypeRequest) DefineIssueRQ(defineIssueRQ DefineIssueRQ) ApiDefineTestItemIssueTypeRequest {
	r.defineIssueRQ = &defineIssueRQ
	return r
}

func (r ApiDefineTestItemIssueTypeRequest) Execute() ([]Issue, *http.Response, error) {
	return r.ApiService.DefineTestItemIssueTypeExecute(r)
}

/*
DefineTestItemIssueType Update issues of specified test items

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiDefineTestItemIssueTypeRequest
*/
func (a *TestItemAPIService) DefineTestItemIssueType(ctx context.Context, projectName string) ApiDefineTestItemIssueTypeRequest {
	return ApiDefineTestItemIssueTypeRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []Issue
func (a *TestItemAPIService) DefineTestItemIssueTypeExecute(r ApiDefineTestItemIssueTypeRequest) ([]Issue, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Issue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.DefineTestItemIssueType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.defineIssueRQ == nil {
		return localVarReturnValue, nil, reportError("defineIssueRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.defineIssueRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteTestItemRequest struct {
	ctx         context.Context
	ApiService  *TestItemAPIService
	itemId      int64
	projectName string
}

func (r ApiDeleteTestItemRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.DeleteTestItemExecute(r)
}

/*
DeleteTestItem Delete test item

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId
	@param projectName
	@return ApiDeleteTestItemRequest
*/
func (a *TestItemAPIService) DeleteTestItem(ctx context.Context, itemId int64, projectName string) ApiDeleteTestItemRequest {
	return ApiDeleteTestItemRequest{
		ApiService:  a,
		ctx:         ctx,
		itemId:      itemId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *TestItemAPIService) DeleteTestItemExecute(r ApiDeleteTestItemRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.DeleteTestItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteTestItemsRequest struct {
	ctx         context.Context
	ApiService  *TestItemAPIService
	ids         *[]int64
	projectName string
}

func (r ApiDeleteTestItemsRequest) Ids(ids []int64) ApiDeleteTestItemsRequest {
	r.ids = &ids
	return r
}

func (r ApiDeleteTestItemsRequest) Execute() ([]OperationCompletionRS, *http.Response, error) {
	return r.ApiService.DeleteTestItemsExecute(r)
}

/*
DeleteTestItems Delete test items by specified ids

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiDeleteTestItemsRequest
*/
func (a *TestItemAPIService) DeleteTestItems(ctx context.Context, projectName string) ApiDeleteTestItemsRequest {
	return ApiDeleteTestItemsRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []OperationCompletionRS
func (a *TestItemAPIService) DeleteTestItemsExecute(r ApiDeleteTestItemsRequest) ([]OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.DeleteTestItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	{
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFinishTestItem2Request struct {
	ctx              context.Context
	ApiService       *TestItemAPIService
	projectName      string
	testItemId       string
	finishTestItemRQ *FinishTestItemRQ
}

func (r ApiFinishTestItem2Request) FinishTestItemRQ(finishTestItemRQ FinishTestItemRQ) ApiFinishTestItem2Request {
	r.finishTestItemRQ = &finishTestItemRQ
	return r
}

func (r ApiFinishTestItem2Request) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.FinishTestItem2Execute(r)
}

/*
FinishTestItem2 Finish test item

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@param testItemId
	@return ApiFinishTestItem2Request
*/
func (a *TestItemAPIService) FinishTestItem2(ctx context.Context, projectName, testItemId string) ApiFinishTestItem2Request {
	return ApiFinishTestItem2Request{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
		testItemId:  testItemId,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *TestItemAPIService) FinishTestItem2Execute(r ApiFinishTestItem2Request) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.FinishTestItem2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/{testItemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"testItemId"+"}", url.PathEscape(parameterValueToString(r.testItemId, "testItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.finishTestItemRQ == nil {
		return localVarReturnValue, nil, reportError("finishTestItemRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.finishTestItemRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFinishTestItem3Request struct {
	ctx              context.Context
	ApiService       *TestItemAPIService
	projectName      string
	testItemId       string
	finishTestItemRQ *FinishTestItemRQ
}

func (r ApiFinishTestItem3Request) FinishTestItemRQ(finishTestItemRQ FinishTestItemRQ) ApiFinishTestItem3Request {
	r.finishTestItemRQ = &finishTestItemRQ
	return r
}

func (r ApiFinishTestItem3Request) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.FinishTestItem3Execute(r)
}

/*
FinishTestItem3 Finish test item

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@param testItemId
	@return ApiFinishTestItem3Request
*/
func (a *TestItemAPIService) FinishTestItem3(ctx context.Context, projectName, testItemId string) ApiFinishTestItem3Request {
	return ApiFinishTestItem3Request{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
		testItemId:  testItemId,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *TestItemAPIService) FinishTestItem3Execute(r ApiFinishTestItem3Request) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.FinishTestItem3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/{testItemId}/"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"testItemId"+"}", url.PathEscape(parameterValueToString(r.testItemId, "testItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.finishTestItemRQ == nil {
		return localVarReturnValue, nil, reportError("finishTestItemRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.finishTestItemRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAttributeKeys1Request struct {
	ctx                   context.Context
	ApiService            *TestItemAPIService
	filterCntAttributeKey *string
	projectName           string
	filterEqName          *string
}

func (r ApiGetAttributeKeys1Request) FilterCntAttributeKey(filterCntAttributeKey string) ApiGetAttributeKeys1Request {
	r.filterCntAttributeKey = &filterCntAttributeKey
	return r
}

func (r ApiGetAttributeKeys1Request) FilterEqName(filterEqName string) ApiGetAttributeKeys1Request {
	r.filterEqName = &filterEqName
	return r
}

func (r ApiGetAttributeKeys1Request) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetAttributeKeys1Execute(r)
}

/*
GetAttributeKeys1 Get all unique attribute keys of step items under specified project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetAttributeKeys1Request
*/
func (a *TestItemAPIService) GetAttributeKeys1(ctx context.Context, projectName string) ApiGetAttributeKeys1Request {
	return ApiGetAttributeKeys1Request{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []string
func (a *TestItemAPIService) GetAttributeKeys1Execute(r ApiGetAttributeKeys1Request) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.GetAttributeKeys1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/step/attribute/keys"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.filterCntAttributeKey == nil {
		return localVarReturnValue, nil, reportError("filterCntAttributeKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "filter.cnt.attributeKey", r.filterCntAttributeKey, "form", "")
	if r.filterEqName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.name", r.filterEqName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAttributeKeysForProjectRequest struct {
	ctx                   context.Context
	ApiService            *TestItemAPIService
	filterCntAttributeKey *string
	filterId              *int64
	projectName           string
	isLatest              *bool
	launchesLimit         *int32
}

func (r ApiGetAttributeKeysForProjectRequest) FilterCntAttributeKey(filterCntAttributeKey string) ApiGetAttributeKeysForProjectRequest {
	r.filterCntAttributeKey = &filterCntAttributeKey
	return r
}

func (r ApiGetAttributeKeysForProjectRequest) FilterId(filterId int64) ApiGetAttributeKeysForProjectRequest {
	r.filterId = &filterId
	return r
}

func (r ApiGetAttributeKeysForProjectRequest) IsLatest(isLatest bool) ApiGetAttributeKeysForProjectRequest {
	r.isLatest = &isLatest
	return r
}

func (r ApiGetAttributeKeysForProjectRequest) LaunchesLimit(launchesLimit int32) ApiGetAttributeKeysForProjectRequest {
	r.launchesLimit = &launchesLimit
	return r
}

func (r ApiGetAttributeKeysForProjectRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetAttributeKeysForProjectExecute(r)
}

/*
GetAttributeKeysForProject Get all unique attribute keys of specified launch

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetAttributeKeysForProjectRequest
*/
func (a *TestItemAPIService) GetAttributeKeysForProject(ctx context.Context, projectName string) ApiGetAttributeKeysForProjectRequest {
	return ApiGetAttributeKeysForProjectRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []string
func (a *TestItemAPIService) GetAttributeKeysForProjectExecute(r ApiGetAttributeKeysForProjectRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.GetAttributeKeysForProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/attribute/keys/all"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.filterCntAttributeKey == nil {
		return localVarReturnValue, nil, reportError("filterCntAttributeKey is required and must be specified")
	}
	if r.filterId == nil {
		return localVarReturnValue, nil, reportError("filterId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "filter.cnt.attributeKey", r.filterCntAttributeKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "filterId", r.filterId, "form", "")
	if r.isLatest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isLatest", r.isLatest, "form", "")
	} else {
		var defaultValue bool = false
		r.isLatest = &defaultValue
	}
	if r.launchesLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "launchesLimit", r.launchesLimit, "form", "")
	} else {
		var defaultValue int32 = 0
		r.launchesLimit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAttributeValues1Request struct {
	ctx                     context.Context
	ApiService              *TestItemAPIService
	filterCntAttributeValue *string
	projectName             string
	filterEqAttributeKey    *string
	filterEqName            *string
}

func (r ApiGetAttributeValues1Request) FilterCntAttributeValue(filterCntAttributeValue string) ApiGetAttributeValues1Request {
	r.filterCntAttributeValue = &filterCntAttributeValue
	return r
}

func (r ApiGetAttributeValues1Request) FilterEqAttributeKey(filterEqAttributeKey string) ApiGetAttributeValues1Request {
	r.filterEqAttributeKey = &filterEqAttributeKey
	return r
}

func (r ApiGetAttributeValues1Request) FilterEqName(filterEqName string) ApiGetAttributeValues1Request {
	r.filterEqName = &filterEqName
	return r
}

func (r ApiGetAttributeValues1Request) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetAttributeValues1Execute(r)
}

/*
GetAttributeValues1 Get all unique attribute values of step items under specified project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetAttributeValues1Request
*/
func (a *TestItemAPIService) GetAttributeValues1(ctx context.Context, projectName string) ApiGetAttributeValues1Request {
	return ApiGetAttributeValues1Request{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []string
func (a *TestItemAPIService) GetAttributeValues1Execute(r ApiGetAttributeValues1Request) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.GetAttributeValues1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/step/attribute/values"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.filterCntAttributeValue == nil {
		return localVarReturnValue, nil, reportError("filterCntAttributeValue is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "filter.cnt.attributeValue", r.filterCntAttributeValue, "form", "")
	if r.filterEqAttributeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeKey", r.filterEqAttributeKey, "form", "")
	}
	if r.filterEqName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.name", r.filterEqName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAttributeValues2Request struct {
	ctx                     context.Context
	ApiService              *TestItemAPIService
	filterCntAttributeValue *string
	projectName             string
	filterEqAttributeKey    *string
	launch                  *int64
}

func (r ApiGetAttributeValues2Request) FilterCntAttributeValue(filterCntAttributeValue string) ApiGetAttributeValues2Request {
	r.filterCntAttributeValue = &filterCntAttributeValue
	return r
}

func (r ApiGetAttributeValues2Request) FilterEqAttributeKey(filterEqAttributeKey string) ApiGetAttributeValues2Request {
	r.filterEqAttributeKey = &filterEqAttributeKey
	return r
}

func (r ApiGetAttributeValues2Request) Launch(launch int64) ApiGetAttributeValues2Request {
	r.launch = &launch
	return r
}

func (r ApiGetAttributeValues2Request) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetAttributeValues2Execute(r)
}

/*
GetAttributeValues2 Get all unique attribute values on the project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetAttributeValues2Request
*/
func (a *TestItemAPIService) GetAttributeValues2(ctx context.Context, projectName string) ApiGetAttributeValues2Request {
	return ApiGetAttributeValues2Request{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []string
func (a *TestItemAPIService) GetAttributeValues2Execute(r ApiGetAttributeValues2Request) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.GetAttributeValues2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/attribute/values"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.filterCntAttributeValue == nil {
		return localVarReturnValue, nil, reportError("filterCntAttributeValue is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "filter.cnt.attributeValue", r.filterCntAttributeValue, "form", "")
	if r.filterEqAttributeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeKey", r.filterEqAttributeKey, "form", "")
	}
	if r.launch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "launch", r.launch, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemsHistoryRequest struct {
	ctx                                         context.Context
	ApiService                                  *TestItemAPIService
	projectName                                 string
	filterId                                    *int64
	historyDepth                                *int32
	isLatest                                    *bool
	launchesLimit                               *int32
	type_                                       *string
	filterEqUuid                                *string
	filterEqAttributeValue                      *[]interface{}
	filterEqLevelAttribute                      *[]interface{}
	filterEqId                                  *int32
	filterEqStatus                              *string
	filterEqStartTime                           *string
	filterEqIssueType                           *string
	filterEqClusterId                           *int32
	filterEqPath                                *int32
	filterEqIssueGroupId                        *string
	filterEqHasRetries                          *bool
	filterEqIssueTypeId                         *int32
	filterEqValue                               *string
	filterEqDuration                            *int32
	filterHasCompositeAttribute                 *string
	filterEqEndTime                             *string
	filterEqStatisticsexecutionspassed          *int32
	filterEqName                                *string
	filterEqAutoAnalyzed                        *bool
	filterEqLocator                             *string
	filterEqDescription                         *string
	filterEqStatisticsexecutionsfailed          *int32
	filterEqTestCaseHash                        *int32
	filterEqStatisticsdefectssystemIssuesi001   *int32
	filterEqHasStats                            *bool
	filterEqStatisticsexecutionstotal           *int32
	filterEqStatisticsexecutionsskipped         *int32
	filterEqLastModified                        *string
	filterEqStatisticsdefectsproductBugpb001    *int32
	filterEqStatisticsdefectsautomationBugab001 *int32
	filterEqType                                *string
	filterEqIssueId                             *int32
	filterEqMode                                *string
	filterEqTestCaseId                          *string
	filterEqUniqueId                            *string
	filterHasCompositeSystemAttribute           *string
	filterEqProjectId                           *int32
	filterEqIssueComment                        *string
	filterEqIgnoreAnalyzer                      *bool
	filterEqLaunchId                            *int32
	filterEqStatisticsdefectsnoDefectnd001      *int32
	filterEqHasChildren                         *bool
	filterEqPatternName                         *[]interface{}
	filterEqRetryParentId                       *int32
	filterEqTicketId                            *string
	filterEqAttributeKey                        *[]interface{}
	filterEqKey                                 *string
	filterEqParentId                            *int32
	filterEqStatisticsdefectstoInvestigateti001 *int32
	pagePage                                    *int32
	pageSize                                    *int32
	pageSort                                    *string
}

func (r ApiGetItemsHistoryRequest) FilterId(filterId int64) ApiGetItemsHistoryRequest {
	r.filterId = &filterId
	return r
}

func (r ApiGetItemsHistoryRequest) HistoryDepth(historyDepth int32) ApiGetItemsHistoryRequest {
	r.historyDepth = &historyDepth
	return r
}

func (r ApiGetItemsHistoryRequest) IsLatest(isLatest bool) ApiGetItemsHistoryRequest {
	r.isLatest = &isLatest
	return r
}

func (r ApiGetItemsHistoryRequest) LaunchesLimit(launchesLimit int32) ApiGetItemsHistoryRequest {
	r.launchesLimit = &launchesLimit
	return r
}

func (r ApiGetItemsHistoryRequest) Type_(type_ string) ApiGetItemsHistoryRequest {
	r.type_ = &type_
	return r
}

// Filters by &#39;uuid&#39;
func (r ApiGetItemsHistoryRequest) FilterEqUuid(filterEqUuid string) ApiGetItemsHistoryRequest {
	r.filterEqUuid = &filterEqUuid
	return r
}

// Filters by &#39;attributeValue&#39;
func (r ApiGetItemsHistoryRequest) FilterEqAttributeValue(filterEqAttributeValue []interface{}) ApiGetItemsHistoryRequest {
	r.filterEqAttributeValue = &filterEqAttributeValue
	return r
}

// Filters by &#39;levelAttribute&#39;
func (r ApiGetItemsHistoryRequest) FilterEqLevelAttribute(filterEqLevelAttribute []interface{}) ApiGetItemsHistoryRequest {
	r.filterEqLevelAttribute = &filterEqLevelAttribute
	return r
}

// Filters by &#39;id&#39;
func (r ApiGetItemsHistoryRequest) FilterEqId(filterEqId int32) ApiGetItemsHistoryRequest {
	r.filterEqId = &filterEqId
	return r
}

// Filters by &#39;status&#39;
func (r ApiGetItemsHistoryRequest) FilterEqStatus(filterEqStatus string) ApiGetItemsHistoryRequest {
	r.filterEqStatus = &filterEqStatus
	return r
}

// Filters by &#39;startTime&#39;
func (r ApiGetItemsHistoryRequest) FilterEqStartTime(filterEqStartTime string) ApiGetItemsHistoryRequest {
	r.filterEqStartTime = &filterEqStartTime
	return r
}

// Filters by &#39;issueType&#39;
func (r ApiGetItemsHistoryRequest) FilterEqIssueType(filterEqIssueType string) ApiGetItemsHistoryRequest {
	r.filterEqIssueType = &filterEqIssueType
	return r
}

// Filters by &#39;clusterId&#39;
func (r ApiGetItemsHistoryRequest) FilterEqClusterId(filterEqClusterId int32) ApiGetItemsHistoryRequest {
	r.filterEqClusterId = &filterEqClusterId
	return r
}

// Filters by &#39;path&#39;
func (r ApiGetItemsHistoryRequest) FilterEqPath(filterEqPath int32) ApiGetItemsHistoryRequest {
	r.filterEqPath = &filterEqPath
	return r
}

// Filters by &#39;issueGroupId&#39;
func (r ApiGetItemsHistoryRequest) FilterEqIssueGroupId(filterEqIssueGroupId string) ApiGetItemsHistoryRequest {
	r.filterEqIssueGroupId = &filterEqIssueGroupId
	return r
}

// Filters by &#39;hasRetries&#39;
func (r ApiGetItemsHistoryRequest) FilterEqHasRetries(filterEqHasRetries bool) ApiGetItemsHistoryRequest {
	r.filterEqHasRetries = &filterEqHasRetries
	return r
}

// Filters by &#39;issueTypeId&#39;
func (r ApiGetItemsHistoryRequest) FilterEqIssueTypeId(filterEqIssueTypeId int32) ApiGetItemsHistoryRequest {
	r.filterEqIssueTypeId = &filterEqIssueTypeId
	return r
}

// Filters by &#39;value&#39;
func (r ApiGetItemsHistoryRequest) FilterEqValue(filterEqValue string) ApiGetItemsHistoryRequest {
	r.filterEqValue = &filterEqValue
	return r
}

// Filters by &#39;duration&#39;
func (r ApiGetItemsHistoryRequest) FilterEqDuration(filterEqDuration int32) ApiGetItemsHistoryRequest {
	r.filterEqDuration = &filterEqDuration
	return r
}

// Filters by &#39;compositeAttribute&#39;
func (r ApiGetItemsHistoryRequest) FilterHasCompositeAttribute(filterHasCompositeAttribute string) ApiGetItemsHistoryRequest {
	r.filterHasCompositeAttribute = &filterHasCompositeAttribute
	return r
}

// Filters by &#39;endTime&#39;
func (r ApiGetItemsHistoryRequest) FilterEqEndTime(filterEqEndTime string) ApiGetItemsHistoryRequest {
	r.filterEqEndTime = &filterEqEndTime
	return r
}

// Filters by &#39;statistics$executions$passed&#39;
func (r ApiGetItemsHistoryRequest) FilterEqStatisticsexecutionspassed(filterEqStatisticsexecutionspassed int32) ApiGetItemsHistoryRequest {
	r.filterEqStatisticsexecutionspassed = &filterEqStatisticsexecutionspassed
	return r
}

// Filters by &#39;name&#39;
func (r ApiGetItemsHistoryRequest) FilterEqName(filterEqName string) ApiGetItemsHistoryRequest {
	r.filterEqName = &filterEqName
	return r
}

// Filters by &#39;autoAnalyzed&#39;
func (r ApiGetItemsHistoryRequest) FilterEqAutoAnalyzed(filterEqAutoAnalyzed bool) ApiGetItemsHistoryRequest {
	r.filterEqAutoAnalyzed = &filterEqAutoAnalyzed
	return r
}

// Filters by &#39;locator&#39;
func (r ApiGetItemsHistoryRequest) FilterEqLocator(filterEqLocator string) ApiGetItemsHistoryRequest {
	r.filterEqLocator = &filterEqLocator
	return r
}

// Filters by &#39;description&#39;
func (r ApiGetItemsHistoryRequest) FilterEqDescription(filterEqDescription string) ApiGetItemsHistoryRequest {
	r.filterEqDescription = &filterEqDescription
	return r
}

// Filters by &#39;statistics$executions$failed&#39;
func (r ApiGetItemsHistoryRequest) FilterEqStatisticsexecutionsfailed(filterEqStatisticsexecutionsfailed int32) ApiGetItemsHistoryRequest {
	r.filterEqStatisticsexecutionsfailed = &filterEqStatisticsexecutionsfailed
	return r
}

// Filters by &#39;testCaseHash&#39;
func (r ApiGetItemsHistoryRequest) FilterEqTestCaseHash(filterEqTestCaseHash int32) ApiGetItemsHistoryRequest {
	r.filterEqTestCaseHash = &filterEqTestCaseHash
	return r
}

// Filters by &#39;statistics$defects$system_issue$si001&#39;
func (r ApiGetItemsHistoryRequest) FilterEqStatisticsdefectssystemIssuesi001(filterEqStatisticsdefectssystemIssuesi001 int32) ApiGetItemsHistoryRequest {
	r.filterEqStatisticsdefectssystemIssuesi001 = &filterEqStatisticsdefectssystemIssuesi001
	return r
}

// Filters by &#39;hasStats&#39;
func (r ApiGetItemsHistoryRequest) FilterEqHasStats(filterEqHasStats bool) ApiGetItemsHistoryRequest {
	r.filterEqHasStats = &filterEqHasStats
	return r
}

// Filters by &#39;statistics$executions$total&#39;
func (r ApiGetItemsHistoryRequest) FilterEqStatisticsexecutionstotal(filterEqStatisticsexecutionstotal int32) ApiGetItemsHistoryRequest {
	r.filterEqStatisticsexecutionstotal = &filterEqStatisticsexecutionstotal
	return r
}

// Filters by &#39;statistics$executions$skipped&#39;
func (r ApiGetItemsHistoryRequest) FilterEqStatisticsexecutionsskipped(filterEqStatisticsexecutionsskipped int32) ApiGetItemsHistoryRequest {
	r.filterEqStatisticsexecutionsskipped = &filterEqStatisticsexecutionsskipped
	return r
}

// Filters by &#39;lastModified&#39;
func (r ApiGetItemsHistoryRequest) FilterEqLastModified(filterEqLastModified string) ApiGetItemsHistoryRequest {
	r.filterEqLastModified = &filterEqLastModified
	return r
}

// Filters by &#39;statistics$defects$product_bug$pb001&#39;
func (r ApiGetItemsHistoryRequest) FilterEqStatisticsdefectsproductBugpb001(filterEqStatisticsdefectsproductBugpb001 int32) ApiGetItemsHistoryRequest {
	r.filterEqStatisticsdefectsproductBugpb001 = &filterEqStatisticsdefectsproductBugpb001
	return r
}

// Filters by &#39;statistics$defects$automation_bug$ab001&#39;
func (r ApiGetItemsHistoryRequest) FilterEqStatisticsdefectsautomationBugab001(filterEqStatisticsdefectsautomationBugab001 int32) ApiGetItemsHistoryRequest {
	r.filterEqStatisticsdefectsautomationBugab001 = &filterEqStatisticsdefectsautomationBugab001
	return r
}

// Filters by &#39;type&#39;
func (r ApiGetItemsHistoryRequest) FilterEqType(filterEqType string) ApiGetItemsHistoryRequest {
	r.filterEqType = &filterEqType
	return r
}

// Filters by &#39;issueId&#39;
func (r ApiGetItemsHistoryRequest) FilterEqIssueId(filterEqIssueId int32) ApiGetItemsHistoryRequest {
	r.filterEqIssueId = &filterEqIssueId
	return r
}

// Filters by &#39;mode&#39;
func (r ApiGetItemsHistoryRequest) FilterEqMode(filterEqMode string) ApiGetItemsHistoryRequest {
	r.filterEqMode = &filterEqMode
	return r
}

// Filters by &#39;testCaseId&#39;
func (r ApiGetItemsHistoryRequest) FilterEqTestCaseId(filterEqTestCaseId string) ApiGetItemsHistoryRequest {
	r.filterEqTestCaseId = &filterEqTestCaseId
	return r
}

// Filters by &#39;uniqueId&#39;
func (r ApiGetItemsHistoryRequest) FilterEqUniqueId(filterEqUniqueId string) ApiGetItemsHistoryRequest {
	r.filterEqUniqueId = &filterEqUniqueId
	return r
}

// Filters by &#39;compositeSystemAttribute&#39;
func (r ApiGetItemsHistoryRequest) FilterHasCompositeSystemAttribute(filterHasCompositeSystemAttribute string) ApiGetItemsHistoryRequest {
	r.filterHasCompositeSystemAttribute = &filterHasCompositeSystemAttribute
	return r
}

// Filters by &#39;projectId&#39;
func (r ApiGetItemsHistoryRequest) FilterEqProjectId(filterEqProjectId int32) ApiGetItemsHistoryRequest {
	r.filterEqProjectId = &filterEqProjectId
	return r
}

// Filters by &#39;issueComment&#39;
func (r ApiGetItemsHistoryRequest) FilterEqIssueComment(filterEqIssueComment string) ApiGetItemsHistoryRequest {
	r.filterEqIssueComment = &filterEqIssueComment
	return r
}

// Filters by &#39;ignoreAnalyzer&#39;
func (r ApiGetItemsHistoryRequest) FilterEqIgnoreAnalyzer(filterEqIgnoreAnalyzer bool) ApiGetItemsHistoryRequest {
	r.filterEqIgnoreAnalyzer = &filterEqIgnoreAnalyzer
	return r
}

// Filters by &#39;launchId&#39;
func (r ApiGetItemsHistoryRequest) FilterEqLaunchId(filterEqLaunchId int32) ApiGetItemsHistoryRequest {
	r.filterEqLaunchId = &filterEqLaunchId
	return r
}

// Filters by &#39;statistics$defects$no_defect$nd001&#39;
func (r ApiGetItemsHistoryRequest) FilterEqStatisticsdefectsnoDefectnd001(filterEqStatisticsdefectsnoDefectnd001 int32) ApiGetItemsHistoryRequest {
	r.filterEqStatisticsdefectsnoDefectnd001 = &filterEqStatisticsdefectsnoDefectnd001
	return r
}

// Filters by &#39;hasChildren&#39;
func (r ApiGetItemsHistoryRequest) FilterEqHasChildren(filterEqHasChildren bool) ApiGetItemsHistoryRequest {
	r.filterEqHasChildren = &filterEqHasChildren
	return r
}

// Filters by &#39;patternName&#39;
func (r ApiGetItemsHistoryRequest) FilterEqPatternName(filterEqPatternName []interface{}) ApiGetItemsHistoryRequest {
	r.filterEqPatternName = &filterEqPatternName
	return r
}

// Filters by &#39;retryParentId&#39;
func (r ApiGetItemsHistoryRequest) FilterEqRetryParentId(filterEqRetryParentId int32) ApiGetItemsHistoryRequest {
	r.filterEqRetryParentId = &filterEqRetryParentId
	return r
}

// Filters by &#39;ticketId&#39;
func (r ApiGetItemsHistoryRequest) FilterEqTicketId(filterEqTicketId string) ApiGetItemsHistoryRequest {
	r.filterEqTicketId = &filterEqTicketId
	return r
}

// Filters by &#39;attributeKey&#39;
func (r ApiGetItemsHistoryRequest) FilterEqAttributeKey(filterEqAttributeKey []interface{}) ApiGetItemsHistoryRequest {
	r.filterEqAttributeKey = &filterEqAttributeKey
	return r
}

// Filters by &#39;key&#39;
func (r ApiGetItemsHistoryRequest) FilterEqKey(filterEqKey string) ApiGetItemsHistoryRequest {
	r.filterEqKey = &filterEqKey
	return r
}

// Filters by &#39;parentId&#39;
func (r ApiGetItemsHistoryRequest) FilterEqParentId(filterEqParentId int32) ApiGetItemsHistoryRequest {
	r.filterEqParentId = &filterEqParentId
	return r
}

// Filters by &#39;statistics$defects$to_investigate$ti001&#39;
func (r ApiGetItemsHistoryRequest) FilterEqStatisticsdefectstoInvestigateti001(filterEqStatisticsdefectstoInvestigateti001 int32) ApiGetItemsHistoryRequest {
	r.filterEqStatisticsdefectstoInvestigateti001 = &filterEqStatisticsdefectstoInvestigateti001
	return r
}

// Results page you want to retrieve (0..N)
func (r ApiGetItemsHistoryRequest) PagePage(pagePage int32) ApiGetItemsHistoryRequest {
	r.pagePage = &pagePage
	return r
}

// Number of records per page
func (r ApiGetItemsHistoryRequest) PageSize(pageSize int32) ApiGetItemsHistoryRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetItemsHistoryRequest) PageSort(pageSort string) ApiGetItemsHistoryRequest {
	r.pageSort = &pageSort
	return r
}

func (r ApiGetItemsHistoryRequest) Execute() (*PageTestItemHistoryElement, *http.Response, error) {
	return r.ApiService.GetItemsHistoryExecute(r)
}

/*
GetItemsHistory Load history of test items

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetItemsHistoryRequest
*/
func (a *TestItemAPIService) GetItemsHistory(ctx context.Context, projectName string) ApiGetItemsHistoryRequest {
	return ApiGetItemsHistoryRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return PageTestItemHistoryElement
func (a *TestItemAPIService) GetItemsHistoryExecute(r ApiGetItemsHistoryRequest) (*PageTestItemHistoryElement, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageTestItemHistoryElement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.GetItemsHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/history"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterId", r.filterId, "form", "")
	}
	if r.historyDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "historyDepth", r.historyDepth, "form", "")
	} else {
		var defaultValue int32 = 5
		r.historyDepth = &defaultValue
	}
	if r.isLatest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isLatest", r.isLatest, "form", "")
	} else {
		var defaultValue bool = false
		r.isLatest = &defaultValue
	}
	if r.launchesLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "launchesLimit", r.launchesLimit, "form", "")
	} else {
		var defaultValue int32 = 0
		r.launchesLimit = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.filterEqUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.uuid", r.filterEqUuid, "form", "")
	}
	if r.filterEqAttributeValue != nil {
		t := *r.filterEqAttributeValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeValue", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeValue", t, "form", "multi")
		}
	}
	if r.filterEqLevelAttribute != nil {
		t := *r.filterEqLevelAttribute
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.levelAttribute", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.levelAttribute", t, "form", "multi")
		}
	}
	if r.filterEqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.id", r.filterEqId, "form", "")
	}
	if r.filterEqStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.status", r.filterEqStatus, "form", "")
	}
	if r.filterEqStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.startTime", r.filterEqStartTime, "form", "")
	}
	if r.filterEqIssueType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.issueType", r.filterEqIssueType, "form", "")
	}
	if r.filterEqClusterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.clusterId", r.filterEqClusterId, "form", "")
	}
	if r.filterEqPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.path", r.filterEqPath, "form", "")
	}
	if r.filterEqIssueGroupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.issueGroupId", r.filterEqIssueGroupId, "form", "")
	}
	if r.filterEqHasRetries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.hasRetries", r.filterEqHasRetries, "form", "")
	}
	if r.filterEqIssueTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.issueTypeId", r.filterEqIssueTypeId, "form", "")
	}
	if r.filterEqValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.value", r.filterEqValue, "form", "")
	}
	if r.filterEqDuration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.duration", r.filterEqDuration, "form", "")
	}
	if r.filterHasCompositeAttribute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.has.compositeAttribute", r.filterHasCompositeAttribute, "form", "")
	}
	if r.filterEqEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.endTime", r.filterEqEndTime, "form", "")
	}
	if r.filterEqStatisticsexecutionspassed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$passed", r.filterEqStatisticsexecutionspassed, "form", "")
	}
	if r.filterEqName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.name", r.filterEqName, "form", "")
	}
	if r.filterEqAutoAnalyzed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.autoAnalyzed", r.filterEqAutoAnalyzed, "form", "")
	}
	if r.filterEqLocator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.locator", r.filterEqLocator, "form", "")
	}
	if r.filterEqDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.description", r.filterEqDescription, "form", "")
	}
	if r.filterEqStatisticsexecutionsfailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$failed", r.filterEqStatisticsexecutionsfailed, "form", "")
	}
	if r.filterEqTestCaseHash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.testCaseHash", r.filterEqTestCaseHash, "form", "")
	}
	if r.filterEqStatisticsdefectssystemIssuesi001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$system_issue$si001", r.filterEqStatisticsdefectssystemIssuesi001, "form", "")
	}
	if r.filterEqHasStats != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.hasStats", r.filterEqHasStats, "form", "")
	}
	if r.filterEqStatisticsexecutionstotal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$total", r.filterEqStatisticsexecutionstotal, "form", "")
	}
	if r.filterEqStatisticsexecutionsskipped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$skipped", r.filterEqStatisticsexecutionsskipped, "form", "")
	}
	if r.filterEqLastModified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.lastModified", r.filterEqLastModified, "form", "")
	}
	if r.filterEqStatisticsdefectsproductBugpb001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$product_bug$pb001", r.filterEqStatisticsdefectsproductBugpb001, "form", "")
	}
	if r.filterEqStatisticsdefectsautomationBugab001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$automation_bug$ab001", r.filterEqStatisticsdefectsautomationBugab001, "form", "")
	}
	if r.filterEqType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.type", r.filterEqType, "form", "")
	}
	if r.filterEqIssueId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.issueId", r.filterEqIssueId, "form", "")
	}
	if r.filterEqMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.mode", r.filterEqMode, "form", "")
	}
	if r.filterEqTestCaseId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.testCaseId", r.filterEqTestCaseId, "form", "")
	}
	if r.filterEqUniqueId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.uniqueId", r.filterEqUniqueId, "form", "")
	}
	if r.filterHasCompositeSystemAttribute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.has.compositeSystemAttribute", r.filterHasCompositeSystemAttribute, "form", "")
	}
	if r.filterEqProjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.projectId", r.filterEqProjectId, "form", "")
	}
	if r.filterEqIssueComment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.issueComment", r.filterEqIssueComment, "form", "")
	}
	if r.filterEqIgnoreAnalyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.ignoreAnalyzer", r.filterEqIgnoreAnalyzer, "form", "")
	}
	if r.filterEqLaunchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.launchId", r.filterEqLaunchId, "form", "")
	}
	if r.filterEqStatisticsdefectsnoDefectnd001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$no_defect$nd001", r.filterEqStatisticsdefectsnoDefectnd001, "form", "")
	}
	if r.filterEqHasChildren != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.hasChildren", r.filterEqHasChildren, "form", "")
	}
	if r.filterEqPatternName != nil {
		t := *r.filterEqPatternName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.patternName", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.patternName", t, "form", "multi")
		}
	}
	if r.filterEqRetryParentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.retryParentId", r.filterEqRetryParentId, "form", "")
	}
	if r.filterEqTicketId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.ticketId", r.filterEqTicketId, "form", "")
	}
	if r.filterEqAttributeKey != nil {
		t := *r.filterEqAttributeKey
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeKey", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeKey", t, "form", "multi")
		}
	}
	if r.filterEqKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.key", r.filterEqKey, "form", "")
	}
	if r.filterEqParentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.parentId", r.filterEqParentId, "form", "")
	}
	if r.filterEqStatisticsdefectstoInvestigateti001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$to_investigate$ti001", r.filterEqStatisticsdefectstoInvestigateti001, "form", "")
	}
	if r.pagePage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.page", r.pagePage, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.sort", r.pageSort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSuggestedClusterItemsRequest struct {
	ctx         context.Context
	ApiService  *TestItemAPIService
	clusterId   int64
	projectName string
}

func (r ApiGetSuggestedClusterItemsRequest) Execute() ([]SuggestedItem, *http.Response, error) {
	return r.ApiService.GetSuggestedClusterItemsExecute(r)
}

/*
GetSuggestedClusterItems Search suggested items in analyzer for provided one

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId
	@param projectName
	@return ApiGetSuggestedClusterItemsRequest
*/
func (a *TestItemAPIService) GetSuggestedClusterItems(ctx context.Context, clusterId int64, projectName string) ApiGetSuggestedClusterItemsRequest {
	return ApiGetSuggestedClusterItemsRequest{
		ApiService:  a,
		ctx:         ctx,
		clusterId:   clusterId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []SuggestedItem
func (a *TestItemAPIService) GetSuggestedClusterItemsExecute(r ApiGetSuggestedClusterItemsRequest) ([]SuggestedItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []SuggestedItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.GetSuggestedClusterItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/suggest/cluster/{clusterId}"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSuggestedItemsRequest struct {
	ctx         context.Context
	ApiService  *TestItemAPIService
	itemId      int64
	projectName string
}

func (r ApiGetSuggestedItemsRequest) Execute() ([]SuggestedItem, *http.Response, error) {
	return r.ApiService.GetSuggestedItemsExecute(r)
}

/*
GetSuggestedItems Search suggested items in analyzer for provided one

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId
	@param projectName
	@return ApiGetSuggestedItemsRequest
*/
func (a *TestItemAPIService) GetSuggestedItems(ctx context.Context, itemId int64, projectName string) ApiGetSuggestedItemsRequest {
	return ApiGetSuggestedItemsRequest{
		ApiService:  a,
		ctx:         ctx,
		itemId:      itemId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []SuggestedItem
func (a *TestItemAPIService) GetSuggestedItemsExecute(r ApiGetSuggestedItemsRequest) ([]SuggestedItem, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []SuggestedItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.GetSuggestedItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/suggest/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTestItemRequest struct {
	ctx         context.Context
	ApiService  *TestItemAPIService
	itemId      string
	projectName string
}

func (r ApiGetTestItemRequest) Execute() (*TestItemResource, *http.Response, error) {
	return r.ApiService.GetTestItemExecute(r)
}

/*
GetTestItem Find test item by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId
	@param projectName
	@return ApiGetTestItemRequest
*/
func (a *TestItemAPIService) GetTestItem(ctx context.Context, itemId, projectName string) ApiGetTestItemRequest {
	return ApiGetTestItemRequest{
		ApiService:  a,
		ctx:         ctx,
		itemId:      itemId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return TestItemResource
func (a *TestItemAPIService) GetTestItemExecute(r ApiGetTestItemRequest) (*TestItemResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TestItemResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.GetTestItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTestItemByUuidTimestampRequest struct {
	ctx         context.Context
	ApiService  *TestItemAPIService
	itemId      string
	projectName string
}

func (r ApiGetTestItemByUuidTimestampRequest) Execute() (*TestItemResourceOld, *http.Response, error) {
	return r.ApiService.GetTestItemByUuidTimestampExecute(r)
}

/*
GetTestItemByUuidTimestamp Find test item by UUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId
	@param projectName
	@return ApiGetTestItemByUuidTimestampRequest
*/
func (a *TestItemAPIService) GetTestItemByUuidTimestamp(ctx context.Context, itemId, projectName string) ApiGetTestItemByUuidTimestampRequest {
	return ApiGetTestItemByUuidTimestampRequest{
		ApiService:  a,
		ctx:         ctx,
		itemId:      itemId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return TestItemResourceOld
func (a *TestItemAPIService) GetTestItemByUuidTimestampExecute(r ApiGetTestItemByUuidTimestampRequest) (*TestItemResourceOld, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TestItemResourceOld
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.GetTestItemByUuidTimestamp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/uuid/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x.reportportal.test.v2+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTestItemsRequest struct {
	ctx                                         context.Context
	ApiService                                  *TestItemAPIService
	projectName                                 string
	filterId                                    *int64
	isLatest                                    *bool
	launchesLimit                               *int32
	filterEqUuid                                *string
	filterEqAttributeValue                      *[]interface{}
	filterEqLevelAttribute                      *[]interface{}
	filterEqId                                  *int32
	filterEqStatus                              *string
	filterEqStartTime                           *string
	filterEqIssueType                           *string
	filterEqClusterId                           *int32
	filterEqPath                                *int32
	filterEqIssueGroupId                        *string
	filterEqHasRetries                          *bool
	filterEqIssueTypeId                         *int32
	filterEqValue                               *string
	filterEqDuration                            *int32
	filterHasCompositeAttribute                 *string
	filterEqEndTime                             *string
	filterEqStatisticsexecutionspassed          *int32
	filterEqName                                *string
	filterEqAutoAnalyzed                        *bool
	filterEqLocator                             *string
	filterEqDescription                         *string
	filterEqStatisticsexecutionsfailed          *int32
	filterEqTestCaseHash                        *int32
	filterEqStatisticsdefectssystemIssuesi001   *int32
	filterEqHasStats                            *bool
	filterEqStatisticsexecutionstotal           *int32
	filterEqStatisticsexecutionsskipped         *int32
	filterEqLastModified                        *string
	filterEqStatisticsdefectsproductBugpb001    *int32
	filterEqStatisticsdefectsautomationBugab001 *int32
	filterEqType                                *string
	filterEqIssueId                             *int32
	filterEqMode                                *string
	filterEqTestCaseId                          *string
	filterEqUniqueId                            *string
	filterHasCompositeSystemAttribute           *string
	filterEqProjectId                           *int32
	filterEqIssueComment                        *string
	filterEqIgnoreAnalyzer                      *bool
	filterEqLaunchId                            *int32
	filterEqStatisticsdefectsnoDefectnd001      *int32
	filterEqHasChildren                         *bool
	filterEqPatternName                         *[]interface{}
	filterEqRetryParentId                       *int32
	filterEqTicketId                            *string
	filterEqAttributeKey                        *[]interface{}
	filterEqKey                                 *string
	filterEqParentId                            *int32
	filterEqStatisticsdefectstoInvestigateti001 *int32
	pagePage                                    *int32
	pageSize                                    *int32
	pageSort                                    *string
}

func (r ApiGetTestItemsRequest) FilterId(filterId int64) ApiGetTestItemsRequest {
	r.filterId = &filterId
	return r
}

func (r ApiGetTestItemsRequest) IsLatest(isLatest bool) ApiGetTestItemsRequest {
	r.isLatest = &isLatest
	return r
}

func (r ApiGetTestItemsRequest) LaunchesLimit(launchesLimit int32) ApiGetTestItemsRequest {
	r.launchesLimit = &launchesLimit
	return r
}

// Filters by &#39;uuid&#39;
func (r ApiGetTestItemsRequest) FilterEqUuid(filterEqUuid string) ApiGetTestItemsRequest {
	r.filterEqUuid = &filterEqUuid
	return r
}

// Filters by &#39;attributeValue&#39;
func (r ApiGetTestItemsRequest) FilterEqAttributeValue(filterEqAttributeValue []interface{}) ApiGetTestItemsRequest {
	r.filterEqAttributeValue = &filterEqAttributeValue
	return r
}

// Filters by &#39;levelAttribute&#39;
func (r ApiGetTestItemsRequest) FilterEqLevelAttribute(filterEqLevelAttribute []interface{}) ApiGetTestItemsRequest {
	r.filterEqLevelAttribute = &filterEqLevelAttribute
	return r
}

// Filters by &#39;id&#39;
func (r ApiGetTestItemsRequest) FilterEqId(filterEqId int32) ApiGetTestItemsRequest {
	r.filterEqId = &filterEqId
	return r
}

// Filters by &#39;status&#39;
func (r ApiGetTestItemsRequest) FilterEqStatus(filterEqStatus string) ApiGetTestItemsRequest {
	r.filterEqStatus = &filterEqStatus
	return r
}

// Filters by &#39;startTime&#39;
func (r ApiGetTestItemsRequest) FilterEqStartTime(filterEqStartTime string) ApiGetTestItemsRequest {
	r.filterEqStartTime = &filterEqStartTime
	return r
}

// Filters by &#39;issueType&#39;
func (r ApiGetTestItemsRequest) FilterEqIssueType(filterEqIssueType string) ApiGetTestItemsRequest {
	r.filterEqIssueType = &filterEqIssueType
	return r
}

// Filters by &#39;clusterId&#39;
func (r ApiGetTestItemsRequest) FilterEqClusterId(filterEqClusterId int32) ApiGetTestItemsRequest {
	r.filterEqClusterId = &filterEqClusterId
	return r
}

// Filters by &#39;path&#39;
func (r ApiGetTestItemsRequest) FilterEqPath(filterEqPath int32) ApiGetTestItemsRequest {
	r.filterEqPath = &filterEqPath
	return r
}

// Filters by &#39;issueGroupId&#39;
func (r ApiGetTestItemsRequest) FilterEqIssueGroupId(filterEqIssueGroupId string) ApiGetTestItemsRequest {
	r.filterEqIssueGroupId = &filterEqIssueGroupId
	return r
}

// Filters by &#39;hasRetries&#39;
func (r ApiGetTestItemsRequest) FilterEqHasRetries(filterEqHasRetries bool) ApiGetTestItemsRequest {
	r.filterEqHasRetries = &filterEqHasRetries
	return r
}

// Filters by &#39;issueTypeId&#39;
func (r ApiGetTestItemsRequest) FilterEqIssueTypeId(filterEqIssueTypeId int32) ApiGetTestItemsRequest {
	r.filterEqIssueTypeId = &filterEqIssueTypeId
	return r
}

// Filters by &#39;value&#39;
func (r ApiGetTestItemsRequest) FilterEqValue(filterEqValue string) ApiGetTestItemsRequest {
	r.filterEqValue = &filterEqValue
	return r
}

// Filters by &#39;duration&#39;
func (r ApiGetTestItemsRequest) FilterEqDuration(filterEqDuration int32) ApiGetTestItemsRequest {
	r.filterEqDuration = &filterEqDuration
	return r
}

// Filters by &#39;compositeAttribute&#39;
func (r ApiGetTestItemsRequest) FilterHasCompositeAttribute(filterHasCompositeAttribute string) ApiGetTestItemsRequest {
	r.filterHasCompositeAttribute = &filterHasCompositeAttribute
	return r
}

// Filters by &#39;endTime&#39;
func (r ApiGetTestItemsRequest) FilterEqEndTime(filterEqEndTime string) ApiGetTestItemsRequest {
	r.filterEqEndTime = &filterEqEndTime
	return r
}

// Filters by &#39;statistics$executions$passed&#39;
func (r ApiGetTestItemsRequest) FilterEqStatisticsexecutionspassed(filterEqStatisticsexecutionspassed int32) ApiGetTestItemsRequest {
	r.filterEqStatisticsexecutionspassed = &filterEqStatisticsexecutionspassed
	return r
}

// Filters by &#39;name&#39;
func (r ApiGetTestItemsRequest) FilterEqName(filterEqName string) ApiGetTestItemsRequest {
	r.filterEqName = &filterEqName
	return r
}

// Filters by &#39;autoAnalyzed&#39;
func (r ApiGetTestItemsRequest) FilterEqAutoAnalyzed(filterEqAutoAnalyzed bool) ApiGetTestItemsRequest {
	r.filterEqAutoAnalyzed = &filterEqAutoAnalyzed
	return r
}

// Filters by &#39;locator&#39;
func (r ApiGetTestItemsRequest) FilterEqLocator(filterEqLocator string) ApiGetTestItemsRequest {
	r.filterEqLocator = &filterEqLocator
	return r
}

// Filters by &#39;description&#39;
func (r ApiGetTestItemsRequest) FilterEqDescription(filterEqDescription string) ApiGetTestItemsRequest {
	r.filterEqDescription = &filterEqDescription
	return r
}

// Filters by &#39;statistics$executions$failed&#39;
func (r ApiGetTestItemsRequest) FilterEqStatisticsexecutionsfailed(filterEqStatisticsexecutionsfailed int32) ApiGetTestItemsRequest {
	r.filterEqStatisticsexecutionsfailed = &filterEqStatisticsexecutionsfailed
	return r
}

// Filters by &#39;testCaseHash&#39;
func (r ApiGetTestItemsRequest) FilterEqTestCaseHash(filterEqTestCaseHash int32) ApiGetTestItemsRequest {
	r.filterEqTestCaseHash = &filterEqTestCaseHash
	return r
}

// Filters by &#39;statistics$defects$system_issue$si001&#39;
func (r ApiGetTestItemsRequest) FilterEqStatisticsdefectssystemIssuesi001(filterEqStatisticsdefectssystemIssuesi001 int32) ApiGetTestItemsRequest {
	r.filterEqStatisticsdefectssystemIssuesi001 = &filterEqStatisticsdefectssystemIssuesi001
	return r
}

// Filters by &#39;hasStats&#39;
func (r ApiGetTestItemsRequest) FilterEqHasStats(filterEqHasStats bool) ApiGetTestItemsRequest {
	r.filterEqHasStats = &filterEqHasStats
	return r
}

// Filters by &#39;statistics$executions$total&#39;
func (r ApiGetTestItemsRequest) FilterEqStatisticsexecutionstotal(filterEqStatisticsexecutionstotal int32) ApiGetTestItemsRequest {
	r.filterEqStatisticsexecutionstotal = &filterEqStatisticsexecutionstotal
	return r
}

// Filters by &#39;statistics$executions$skipped&#39;
func (r ApiGetTestItemsRequest) FilterEqStatisticsexecutionsskipped(filterEqStatisticsexecutionsskipped int32) ApiGetTestItemsRequest {
	r.filterEqStatisticsexecutionsskipped = &filterEqStatisticsexecutionsskipped
	return r
}

// Filters by &#39;lastModified&#39;
func (r ApiGetTestItemsRequest) FilterEqLastModified(filterEqLastModified string) ApiGetTestItemsRequest {
	r.filterEqLastModified = &filterEqLastModified
	return r
}

// Filters by &#39;statistics$defects$product_bug$pb001&#39;
func (r ApiGetTestItemsRequest) FilterEqStatisticsdefectsproductBugpb001(filterEqStatisticsdefectsproductBugpb001 int32) ApiGetTestItemsRequest {
	r.filterEqStatisticsdefectsproductBugpb001 = &filterEqStatisticsdefectsproductBugpb001
	return r
}

// Filters by &#39;statistics$defects$automation_bug$ab001&#39;
func (r ApiGetTestItemsRequest) FilterEqStatisticsdefectsautomationBugab001(filterEqStatisticsdefectsautomationBugab001 int32) ApiGetTestItemsRequest {
	r.filterEqStatisticsdefectsautomationBugab001 = &filterEqStatisticsdefectsautomationBugab001
	return r
}

// Filters by &#39;type&#39;
func (r ApiGetTestItemsRequest) FilterEqType(filterEqType string) ApiGetTestItemsRequest {
	r.filterEqType = &filterEqType
	return r
}

// Filters by &#39;issueId&#39;
func (r ApiGetTestItemsRequest) FilterEqIssueId(filterEqIssueId int32) ApiGetTestItemsRequest {
	r.filterEqIssueId = &filterEqIssueId
	return r
}

// Filters by &#39;mode&#39;
func (r ApiGetTestItemsRequest) FilterEqMode(filterEqMode string) ApiGetTestItemsRequest {
	r.filterEqMode = &filterEqMode
	return r
}

// Filters by &#39;testCaseId&#39;
func (r ApiGetTestItemsRequest) FilterEqTestCaseId(filterEqTestCaseId string) ApiGetTestItemsRequest {
	r.filterEqTestCaseId = &filterEqTestCaseId
	return r
}

// Filters by &#39;uniqueId&#39;
func (r ApiGetTestItemsRequest) FilterEqUniqueId(filterEqUniqueId string) ApiGetTestItemsRequest {
	r.filterEqUniqueId = &filterEqUniqueId
	return r
}

// Filters by &#39;compositeSystemAttribute&#39;
func (r ApiGetTestItemsRequest) FilterHasCompositeSystemAttribute(filterHasCompositeSystemAttribute string) ApiGetTestItemsRequest {
	r.filterHasCompositeSystemAttribute = &filterHasCompositeSystemAttribute
	return r
}

// Filters by &#39;projectId&#39;
func (r ApiGetTestItemsRequest) FilterEqProjectId(filterEqProjectId int32) ApiGetTestItemsRequest {
	r.filterEqProjectId = &filterEqProjectId
	return r
}

// Filters by &#39;issueComment&#39;
func (r ApiGetTestItemsRequest) FilterEqIssueComment(filterEqIssueComment string) ApiGetTestItemsRequest {
	r.filterEqIssueComment = &filterEqIssueComment
	return r
}

// Filters by &#39;ignoreAnalyzer&#39;
func (r ApiGetTestItemsRequest) FilterEqIgnoreAnalyzer(filterEqIgnoreAnalyzer bool) ApiGetTestItemsRequest {
	r.filterEqIgnoreAnalyzer = &filterEqIgnoreAnalyzer
	return r
}

// Filters by &#39;launchId&#39;
func (r ApiGetTestItemsRequest) FilterEqLaunchId(filterEqLaunchId int32) ApiGetTestItemsRequest {
	r.filterEqLaunchId = &filterEqLaunchId
	return r
}

// Filters by &#39;statistics$defects$no_defect$nd001&#39;
func (r ApiGetTestItemsRequest) FilterEqStatisticsdefectsnoDefectnd001(filterEqStatisticsdefectsnoDefectnd001 int32) ApiGetTestItemsRequest {
	r.filterEqStatisticsdefectsnoDefectnd001 = &filterEqStatisticsdefectsnoDefectnd001
	return r
}

// Filters by &#39;hasChildren&#39;
func (r ApiGetTestItemsRequest) FilterEqHasChildren(filterEqHasChildren bool) ApiGetTestItemsRequest {
	r.filterEqHasChildren = &filterEqHasChildren
	return r
}

// Filters by &#39;patternName&#39;
func (r ApiGetTestItemsRequest) FilterEqPatternName(filterEqPatternName []interface{}) ApiGetTestItemsRequest {
	r.filterEqPatternName = &filterEqPatternName
	return r
}

// Filters by &#39;retryParentId&#39;
func (r ApiGetTestItemsRequest) FilterEqRetryParentId(filterEqRetryParentId int32) ApiGetTestItemsRequest {
	r.filterEqRetryParentId = &filterEqRetryParentId
	return r
}

// Filters by &#39;ticketId&#39;
func (r ApiGetTestItemsRequest) FilterEqTicketId(filterEqTicketId string) ApiGetTestItemsRequest {
	r.filterEqTicketId = &filterEqTicketId
	return r
}

// Filters by &#39;attributeKey&#39;
func (r ApiGetTestItemsRequest) FilterEqAttributeKey(filterEqAttributeKey []interface{}) ApiGetTestItemsRequest {
	r.filterEqAttributeKey = &filterEqAttributeKey
	return r
}

// Filters by &#39;key&#39;
func (r ApiGetTestItemsRequest) FilterEqKey(filterEqKey string) ApiGetTestItemsRequest {
	r.filterEqKey = &filterEqKey
	return r
}

// Filters by &#39;parentId&#39;
func (r ApiGetTestItemsRequest) FilterEqParentId(filterEqParentId int32) ApiGetTestItemsRequest {
	r.filterEqParentId = &filterEqParentId
	return r
}

// Filters by &#39;statistics$defects$to_investigate$ti001&#39;
func (r ApiGetTestItemsRequest) FilterEqStatisticsdefectstoInvestigateti001(filterEqStatisticsdefectstoInvestigateti001 int32) ApiGetTestItemsRequest {
	r.filterEqStatisticsdefectstoInvestigateti001 = &filterEqStatisticsdefectstoInvestigateti001
	return r
}

// Results page you want to retrieve (0..N)
func (r ApiGetTestItemsRequest) PagePage(pagePage int32) ApiGetTestItemsRequest {
	r.pagePage = &pagePage
	return r
}

// Number of records per page
func (r ApiGetTestItemsRequest) PageSize(pageSize int32) ApiGetTestItemsRequest {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetTestItemsRequest) PageSort(pageSort string) ApiGetTestItemsRequest {
	r.pageSort = &pageSort
	return r
}

func (r ApiGetTestItemsRequest) Execute() (*PageTestItemResource, *http.Response, error) {
	return r.ApiService.GetTestItemsExecute(r)
}

/*
GetTestItems Find test items by specified filter

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetTestItemsRequest
*/
func (a *TestItemAPIService) GetTestItems(ctx context.Context, projectName string) ApiGetTestItemsRequest {
	return ApiGetTestItemsRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return PageTestItemResource
func (a *TestItemAPIService) GetTestItemsExecute(r ApiGetTestItemsRequest) (*PageTestItemResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageTestItemResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.GetTestItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterId", r.filterId, "form", "")
	}
	if r.isLatest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isLatest", r.isLatest, "form", "")
	} else {
		var defaultValue bool = false
		r.isLatest = &defaultValue
	}
	if r.launchesLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "launchesLimit", r.launchesLimit, "form", "")
	} else {
		var defaultValue int32 = 0
		r.launchesLimit = &defaultValue
	}
	if r.filterEqUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.uuid", r.filterEqUuid, "form", "")
	}
	if r.filterEqAttributeValue != nil {
		t := *r.filterEqAttributeValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeValue", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeValue", t, "form", "multi")
		}
	}
	if r.filterEqLevelAttribute != nil {
		t := *r.filterEqLevelAttribute
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.levelAttribute", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.levelAttribute", t, "form", "multi")
		}
	}
	if r.filterEqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.id", r.filterEqId, "form", "")
	}
	if r.filterEqStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.status", r.filterEqStatus, "form", "")
	}
	if r.filterEqStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.startTime", r.filterEqStartTime, "form", "")
	}
	if r.filterEqIssueType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.issueType", r.filterEqIssueType, "form", "")
	}
	if r.filterEqClusterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.clusterId", r.filterEqClusterId, "form", "")
	}
	if r.filterEqPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.path", r.filterEqPath, "form", "")
	}
	if r.filterEqIssueGroupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.issueGroupId", r.filterEqIssueGroupId, "form", "")
	}
	if r.filterEqHasRetries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.hasRetries", r.filterEqHasRetries, "form", "")
	}
	if r.filterEqIssueTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.issueTypeId", r.filterEqIssueTypeId, "form", "")
	}
	if r.filterEqValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.value", r.filterEqValue, "form", "")
	}
	if r.filterEqDuration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.duration", r.filterEqDuration, "form", "")
	}
	if r.filterHasCompositeAttribute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.has.compositeAttribute", r.filterHasCompositeAttribute, "form", "")
	}
	if r.filterEqEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.endTime", r.filterEqEndTime, "form", "")
	}
	if r.filterEqStatisticsexecutionspassed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$passed", r.filterEqStatisticsexecutionspassed, "form", "")
	}
	if r.filterEqName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.name", r.filterEqName, "form", "")
	}
	if r.filterEqAutoAnalyzed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.autoAnalyzed", r.filterEqAutoAnalyzed, "form", "")
	}
	if r.filterEqLocator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.locator", r.filterEqLocator, "form", "")
	}
	if r.filterEqDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.description", r.filterEqDescription, "form", "")
	}
	if r.filterEqStatisticsexecutionsfailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$failed", r.filterEqStatisticsexecutionsfailed, "form", "")
	}
	if r.filterEqTestCaseHash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.testCaseHash", r.filterEqTestCaseHash, "form", "")
	}
	if r.filterEqStatisticsdefectssystemIssuesi001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$system_issue$si001", r.filterEqStatisticsdefectssystemIssuesi001, "form", "")
	}
	if r.filterEqHasStats != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.hasStats", r.filterEqHasStats, "form", "")
	}
	if r.filterEqStatisticsexecutionstotal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$total", r.filterEqStatisticsexecutionstotal, "form", "")
	}
	if r.filterEqStatisticsexecutionsskipped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$skipped", r.filterEqStatisticsexecutionsskipped, "form", "")
	}
	if r.filterEqLastModified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.lastModified", r.filterEqLastModified, "form", "")
	}
	if r.filterEqStatisticsdefectsproductBugpb001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$product_bug$pb001", r.filterEqStatisticsdefectsproductBugpb001, "form", "")
	}
	if r.filterEqStatisticsdefectsautomationBugab001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$automation_bug$ab001", r.filterEqStatisticsdefectsautomationBugab001, "form", "")
	}
	if r.filterEqType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.type", r.filterEqType, "form", "")
	}
	if r.filterEqIssueId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.issueId", r.filterEqIssueId, "form", "")
	}
	if r.filterEqMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.mode", r.filterEqMode, "form", "")
	}
	if r.filterEqTestCaseId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.testCaseId", r.filterEqTestCaseId, "form", "")
	}
	if r.filterEqUniqueId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.uniqueId", r.filterEqUniqueId, "form", "")
	}
	if r.filterHasCompositeSystemAttribute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.has.compositeSystemAttribute", r.filterHasCompositeSystemAttribute, "form", "")
	}
	if r.filterEqProjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.projectId", r.filterEqProjectId, "form", "")
	}
	if r.filterEqIssueComment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.issueComment", r.filterEqIssueComment, "form", "")
	}
	if r.filterEqIgnoreAnalyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.ignoreAnalyzer", r.filterEqIgnoreAnalyzer, "form", "")
	}
	if r.filterEqLaunchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.launchId", r.filterEqLaunchId, "form", "")
	}
	if r.filterEqStatisticsdefectsnoDefectnd001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$no_defect$nd001", r.filterEqStatisticsdefectsnoDefectnd001, "form", "")
	}
	if r.filterEqHasChildren != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.hasChildren", r.filterEqHasChildren, "form", "")
	}
	if r.filterEqPatternName != nil {
		t := *r.filterEqPatternName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.patternName", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.patternName", t, "form", "multi")
		}
	}
	if r.filterEqRetryParentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.retryParentId", r.filterEqRetryParentId, "form", "")
	}
	if r.filterEqTicketId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.ticketId", r.filterEqTicketId, "form", "")
	}
	if r.filterEqAttributeKey != nil {
		t := *r.filterEqAttributeKey
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeKey", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeKey", t, "form", "multi")
		}
	}
	if r.filterEqKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.key", r.filterEqKey, "form", "")
	}
	if r.filterEqParentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.parentId", r.filterEqParentId, "form", "")
	}
	if r.filterEqStatisticsdefectstoInvestigateti001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$to_investigate$ti001", r.filterEqStatisticsdefectstoInvestigateti001, "form", "")
	}
	if r.pagePage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.page", r.pagePage, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.sort", r.pageSort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTestItems1Request struct {
	ctx                                         context.Context
	ApiService                                  *TestItemAPIService
	params                                      *map[string]string
	projectName                                 string
	filterEqUuid                                *string
	filterEqAttributeValue                      *[]interface{}
	filterEqLevelAttribute                      *[]interface{}
	filterEqId                                  *int32
	filterEqStatus                              *string
	filterEqStartTime                           *string
	filterEqIssueType                           *string
	filterEqClusterId                           *int32
	filterEqPath                                *int32
	filterEqIssueGroupId                        *string
	filterEqHasRetries                          *bool
	filterEqIssueTypeId                         *int32
	filterEqValue                               *string
	filterEqDuration                            *int32
	filterHasCompositeAttribute                 *string
	filterEqEndTime                             *string
	filterEqStatisticsexecutionspassed          *int32
	filterEqName                                *string
	filterEqAutoAnalyzed                        *bool
	filterEqLocator                             *string
	filterEqDescription                         *string
	filterEqStatisticsexecutionsfailed          *int32
	filterEqTestCaseHash                        *int32
	filterEqStatisticsdefectssystemIssuesi001   *int32
	filterEqHasStats                            *bool
	filterEqStatisticsexecutionstotal           *int32
	filterEqStatisticsexecutionsskipped         *int32
	filterEqLastModified                        *string
	filterEqStatisticsdefectsproductBugpb001    *int32
	filterEqStatisticsdefectsautomationBugab001 *int32
	filterEqType                                *string
	filterEqIssueId                             *int32
	filterEqMode                                *string
	filterEqTestCaseId                          *string
	filterEqUniqueId                            *string
	filterHasCompositeSystemAttribute           *string
	filterEqProjectId                           *int32
	filterEqIssueComment                        *string
	filterEqIgnoreAnalyzer                      *bool
	filterEqLaunchId                            *int32
	filterEqStatisticsdefectsnoDefectnd001      *int32
	filterEqHasChildren                         *bool
	filterEqPatternName                         *[]interface{}
	filterEqRetryParentId                       *int32
	filterEqTicketId                            *string
	filterEqAttributeKey                        *[]interface{}
	filterEqKey                                 *string
	filterEqParentId                            *int32
	filterEqStatisticsdefectstoInvestigateti001 *int32
}

func (r ApiGetTestItems1Request) Params(params map[string]string) ApiGetTestItems1Request {
	r.params = &params
	return r
}

// Filters by &#39;uuid&#39;
func (r ApiGetTestItems1Request) FilterEqUuid(filterEqUuid string) ApiGetTestItems1Request {
	r.filterEqUuid = &filterEqUuid
	return r
}

// Filters by &#39;attributeValue&#39;
func (r ApiGetTestItems1Request) FilterEqAttributeValue(filterEqAttributeValue []interface{}) ApiGetTestItems1Request {
	r.filterEqAttributeValue = &filterEqAttributeValue
	return r
}

// Filters by &#39;levelAttribute&#39;
func (r ApiGetTestItems1Request) FilterEqLevelAttribute(filterEqLevelAttribute []interface{}) ApiGetTestItems1Request {
	r.filterEqLevelAttribute = &filterEqLevelAttribute
	return r
}

// Filters by &#39;id&#39;
func (r ApiGetTestItems1Request) FilterEqId(filterEqId int32) ApiGetTestItems1Request {
	r.filterEqId = &filterEqId
	return r
}

// Filters by &#39;status&#39;
func (r ApiGetTestItems1Request) FilterEqStatus(filterEqStatus string) ApiGetTestItems1Request {
	r.filterEqStatus = &filterEqStatus
	return r
}

// Filters by &#39;startTime&#39;
func (r ApiGetTestItems1Request) FilterEqStartTime(filterEqStartTime string) ApiGetTestItems1Request {
	r.filterEqStartTime = &filterEqStartTime
	return r
}

// Filters by &#39;issueType&#39;
func (r ApiGetTestItems1Request) FilterEqIssueType(filterEqIssueType string) ApiGetTestItems1Request {
	r.filterEqIssueType = &filterEqIssueType
	return r
}

// Filters by &#39;clusterId&#39;
func (r ApiGetTestItems1Request) FilterEqClusterId(filterEqClusterId int32) ApiGetTestItems1Request {
	r.filterEqClusterId = &filterEqClusterId
	return r
}

// Filters by &#39;path&#39;
func (r ApiGetTestItems1Request) FilterEqPath(filterEqPath int32) ApiGetTestItems1Request {
	r.filterEqPath = &filterEqPath
	return r
}

// Filters by &#39;issueGroupId&#39;
func (r ApiGetTestItems1Request) FilterEqIssueGroupId(filterEqIssueGroupId string) ApiGetTestItems1Request {
	r.filterEqIssueGroupId = &filterEqIssueGroupId
	return r
}

// Filters by &#39;hasRetries&#39;
func (r ApiGetTestItems1Request) FilterEqHasRetries(filterEqHasRetries bool) ApiGetTestItems1Request {
	r.filterEqHasRetries = &filterEqHasRetries
	return r
}

// Filters by &#39;issueTypeId&#39;
func (r ApiGetTestItems1Request) FilterEqIssueTypeId(filterEqIssueTypeId int32) ApiGetTestItems1Request {
	r.filterEqIssueTypeId = &filterEqIssueTypeId
	return r
}

// Filters by &#39;value&#39;
func (r ApiGetTestItems1Request) FilterEqValue(filterEqValue string) ApiGetTestItems1Request {
	r.filterEqValue = &filterEqValue
	return r
}

// Filters by &#39;duration&#39;
func (r ApiGetTestItems1Request) FilterEqDuration(filterEqDuration int32) ApiGetTestItems1Request {
	r.filterEqDuration = &filterEqDuration
	return r
}

// Filters by &#39;compositeAttribute&#39;
func (r ApiGetTestItems1Request) FilterHasCompositeAttribute(filterHasCompositeAttribute string) ApiGetTestItems1Request {
	r.filterHasCompositeAttribute = &filterHasCompositeAttribute
	return r
}

// Filters by &#39;endTime&#39;
func (r ApiGetTestItems1Request) FilterEqEndTime(filterEqEndTime string) ApiGetTestItems1Request {
	r.filterEqEndTime = &filterEqEndTime
	return r
}

// Filters by &#39;statistics$executions$passed&#39;
func (r ApiGetTestItems1Request) FilterEqStatisticsexecutionspassed(filterEqStatisticsexecutionspassed int32) ApiGetTestItems1Request {
	r.filterEqStatisticsexecutionspassed = &filterEqStatisticsexecutionspassed
	return r
}

// Filters by &#39;name&#39;
func (r ApiGetTestItems1Request) FilterEqName(filterEqName string) ApiGetTestItems1Request {
	r.filterEqName = &filterEqName
	return r
}

// Filters by &#39;autoAnalyzed&#39;
func (r ApiGetTestItems1Request) FilterEqAutoAnalyzed(filterEqAutoAnalyzed bool) ApiGetTestItems1Request {
	r.filterEqAutoAnalyzed = &filterEqAutoAnalyzed
	return r
}

// Filters by &#39;locator&#39;
func (r ApiGetTestItems1Request) FilterEqLocator(filterEqLocator string) ApiGetTestItems1Request {
	r.filterEqLocator = &filterEqLocator
	return r
}

// Filters by &#39;description&#39;
func (r ApiGetTestItems1Request) FilterEqDescription(filterEqDescription string) ApiGetTestItems1Request {
	r.filterEqDescription = &filterEqDescription
	return r
}

// Filters by &#39;statistics$executions$failed&#39;
func (r ApiGetTestItems1Request) FilterEqStatisticsexecutionsfailed(filterEqStatisticsexecutionsfailed int32) ApiGetTestItems1Request {
	r.filterEqStatisticsexecutionsfailed = &filterEqStatisticsexecutionsfailed
	return r
}

// Filters by &#39;testCaseHash&#39;
func (r ApiGetTestItems1Request) FilterEqTestCaseHash(filterEqTestCaseHash int32) ApiGetTestItems1Request {
	r.filterEqTestCaseHash = &filterEqTestCaseHash
	return r
}

// Filters by &#39;statistics$defects$system_issue$si001&#39;
func (r ApiGetTestItems1Request) FilterEqStatisticsdefectssystemIssuesi001(filterEqStatisticsdefectssystemIssuesi001 int32) ApiGetTestItems1Request {
	r.filterEqStatisticsdefectssystemIssuesi001 = &filterEqStatisticsdefectssystemIssuesi001
	return r
}

// Filters by &#39;hasStats&#39;
func (r ApiGetTestItems1Request) FilterEqHasStats(filterEqHasStats bool) ApiGetTestItems1Request {
	r.filterEqHasStats = &filterEqHasStats
	return r
}

// Filters by &#39;statistics$executions$total&#39;
func (r ApiGetTestItems1Request) FilterEqStatisticsexecutionstotal(filterEqStatisticsexecutionstotal int32) ApiGetTestItems1Request {
	r.filterEqStatisticsexecutionstotal = &filterEqStatisticsexecutionstotal
	return r
}

// Filters by &#39;statistics$executions$skipped&#39;
func (r ApiGetTestItems1Request) FilterEqStatisticsexecutionsskipped(filterEqStatisticsexecutionsskipped int32) ApiGetTestItems1Request {
	r.filterEqStatisticsexecutionsskipped = &filterEqStatisticsexecutionsskipped
	return r
}

// Filters by &#39;lastModified&#39;
func (r ApiGetTestItems1Request) FilterEqLastModified(filterEqLastModified string) ApiGetTestItems1Request {
	r.filterEqLastModified = &filterEqLastModified
	return r
}

// Filters by &#39;statistics$defects$product_bug$pb001&#39;
func (r ApiGetTestItems1Request) FilterEqStatisticsdefectsproductBugpb001(filterEqStatisticsdefectsproductBugpb001 int32) ApiGetTestItems1Request {
	r.filterEqStatisticsdefectsproductBugpb001 = &filterEqStatisticsdefectsproductBugpb001
	return r
}

// Filters by &#39;statistics$defects$automation_bug$ab001&#39;
func (r ApiGetTestItems1Request) FilterEqStatisticsdefectsautomationBugab001(filterEqStatisticsdefectsautomationBugab001 int32) ApiGetTestItems1Request {
	r.filterEqStatisticsdefectsautomationBugab001 = &filterEqStatisticsdefectsautomationBugab001
	return r
}

// Filters by &#39;type&#39;
func (r ApiGetTestItems1Request) FilterEqType(filterEqType string) ApiGetTestItems1Request {
	r.filterEqType = &filterEqType
	return r
}

// Filters by &#39;issueId&#39;
func (r ApiGetTestItems1Request) FilterEqIssueId(filterEqIssueId int32) ApiGetTestItems1Request {
	r.filterEqIssueId = &filterEqIssueId
	return r
}

// Filters by &#39;mode&#39;
func (r ApiGetTestItems1Request) FilterEqMode(filterEqMode string) ApiGetTestItems1Request {
	r.filterEqMode = &filterEqMode
	return r
}

// Filters by &#39;testCaseId&#39;
func (r ApiGetTestItems1Request) FilterEqTestCaseId(filterEqTestCaseId string) ApiGetTestItems1Request {
	r.filterEqTestCaseId = &filterEqTestCaseId
	return r
}

// Filters by &#39;uniqueId&#39;
func (r ApiGetTestItems1Request) FilterEqUniqueId(filterEqUniqueId string) ApiGetTestItems1Request {
	r.filterEqUniqueId = &filterEqUniqueId
	return r
}

// Filters by &#39;compositeSystemAttribute&#39;
func (r ApiGetTestItems1Request) FilterHasCompositeSystemAttribute(filterHasCompositeSystemAttribute string) ApiGetTestItems1Request {
	r.filterHasCompositeSystemAttribute = &filterHasCompositeSystemAttribute
	return r
}

// Filters by &#39;projectId&#39;
func (r ApiGetTestItems1Request) FilterEqProjectId(filterEqProjectId int32) ApiGetTestItems1Request {
	r.filterEqProjectId = &filterEqProjectId
	return r
}

// Filters by &#39;issueComment&#39;
func (r ApiGetTestItems1Request) FilterEqIssueComment(filterEqIssueComment string) ApiGetTestItems1Request {
	r.filterEqIssueComment = &filterEqIssueComment
	return r
}

// Filters by &#39;ignoreAnalyzer&#39;
func (r ApiGetTestItems1Request) FilterEqIgnoreAnalyzer(filterEqIgnoreAnalyzer bool) ApiGetTestItems1Request {
	r.filterEqIgnoreAnalyzer = &filterEqIgnoreAnalyzer
	return r
}

// Filters by &#39;launchId&#39;
func (r ApiGetTestItems1Request) FilterEqLaunchId(filterEqLaunchId int32) ApiGetTestItems1Request {
	r.filterEqLaunchId = &filterEqLaunchId
	return r
}

// Filters by &#39;statistics$defects$no_defect$nd001&#39;
func (r ApiGetTestItems1Request) FilterEqStatisticsdefectsnoDefectnd001(filterEqStatisticsdefectsnoDefectnd001 int32) ApiGetTestItems1Request {
	r.filterEqStatisticsdefectsnoDefectnd001 = &filterEqStatisticsdefectsnoDefectnd001
	return r
}

// Filters by &#39;hasChildren&#39;
func (r ApiGetTestItems1Request) FilterEqHasChildren(filterEqHasChildren bool) ApiGetTestItems1Request {
	r.filterEqHasChildren = &filterEqHasChildren
	return r
}

// Filters by &#39;patternName&#39;
func (r ApiGetTestItems1Request) FilterEqPatternName(filterEqPatternName []interface{}) ApiGetTestItems1Request {
	r.filterEqPatternName = &filterEqPatternName
	return r
}

// Filters by &#39;retryParentId&#39;
func (r ApiGetTestItems1Request) FilterEqRetryParentId(filterEqRetryParentId int32) ApiGetTestItems1Request {
	r.filterEqRetryParentId = &filterEqRetryParentId
	return r
}

// Filters by &#39;ticketId&#39;
func (r ApiGetTestItems1Request) FilterEqTicketId(filterEqTicketId string) ApiGetTestItems1Request {
	r.filterEqTicketId = &filterEqTicketId
	return r
}

// Filters by &#39;attributeKey&#39;
func (r ApiGetTestItems1Request) FilterEqAttributeKey(filterEqAttributeKey []interface{}) ApiGetTestItems1Request {
	r.filterEqAttributeKey = &filterEqAttributeKey
	return r
}

// Filters by &#39;key&#39;
func (r ApiGetTestItems1Request) FilterEqKey(filterEqKey string) ApiGetTestItems1Request {
	r.filterEqKey = &filterEqKey
	return r
}

// Filters by &#39;parentId&#39;
func (r ApiGetTestItems1Request) FilterEqParentId(filterEqParentId int32) ApiGetTestItems1Request {
	r.filterEqParentId = &filterEqParentId
	return r
}

// Filters by &#39;statistics$defects$to_investigate$ti001&#39;
func (r ApiGetTestItems1Request) FilterEqStatisticsdefectstoInvestigateti001(filterEqStatisticsdefectstoInvestigateti001 int32) ApiGetTestItems1Request {
	r.filterEqStatisticsdefectstoInvestigateti001 = &filterEqStatisticsdefectstoInvestigateti001
	return r
}

func (r ApiGetTestItems1Request) Execute() (*StatisticsResource, *http.Response, error) {
	return r.ApiService.GetTestItems1Execute(r)
}

/*
GetTestItems1 Find accumulated statistics of items by specified filter

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetTestItems1Request
*/
func (a *TestItemAPIService) GetTestItems1(ctx context.Context, projectName string) ApiGetTestItems1Request {
	return ApiGetTestItems1Request{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return StatisticsResource
func (a *TestItemAPIService) GetTestItems1Execute(r ApiGetTestItems1Request) (*StatisticsResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StatisticsResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.GetTestItems1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/statistics"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.params == nil {
		return localVarReturnValue, nil, reportError("params is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	if r.filterEqUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.uuid", r.filterEqUuid, "form", "")
	}
	if r.filterEqAttributeValue != nil {
		t := *r.filterEqAttributeValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeValue", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeValue", t, "form", "multi")
		}
	}
	if r.filterEqLevelAttribute != nil {
		t := *r.filterEqLevelAttribute
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.levelAttribute", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.levelAttribute", t, "form", "multi")
		}
	}
	if r.filterEqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.id", r.filterEqId, "form", "")
	}
	if r.filterEqStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.status", r.filterEqStatus, "form", "")
	}
	if r.filterEqStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.startTime", r.filterEqStartTime, "form", "")
	}
	if r.filterEqIssueType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.issueType", r.filterEqIssueType, "form", "")
	}
	if r.filterEqClusterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.clusterId", r.filterEqClusterId, "form", "")
	}
	if r.filterEqPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.path", r.filterEqPath, "form", "")
	}
	if r.filterEqIssueGroupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.issueGroupId", r.filterEqIssueGroupId, "form", "")
	}
	if r.filterEqHasRetries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.hasRetries", r.filterEqHasRetries, "form", "")
	}
	if r.filterEqIssueTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.issueTypeId", r.filterEqIssueTypeId, "form", "")
	}
	if r.filterEqValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.value", r.filterEqValue, "form", "")
	}
	if r.filterEqDuration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.duration", r.filterEqDuration, "form", "")
	}
	if r.filterHasCompositeAttribute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.has.compositeAttribute", r.filterHasCompositeAttribute, "form", "")
	}
	if r.filterEqEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.endTime", r.filterEqEndTime, "form", "")
	}
	if r.filterEqStatisticsexecutionspassed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$passed", r.filterEqStatisticsexecutionspassed, "form", "")
	}
	if r.filterEqName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.name", r.filterEqName, "form", "")
	}
	if r.filterEqAutoAnalyzed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.autoAnalyzed", r.filterEqAutoAnalyzed, "form", "")
	}
	if r.filterEqLocator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.locator", r.filterEqLocator, "form", "")
	}
	if r.filterEqDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.description", r.filterEqDescription, "form", "")
	}
	if r.filterEqStatisticsexecutionsfailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$failed", r.filterEqStatisticsexecutionsfailed, "form", "")
	}
	if r.filterEqTestCaseHash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.testCaseHash", r.filterEqTestCaseHash, "form", "")
	}
	if r.filterEqStatisticsdefectssystemIssuesi001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$system_issue$si001", r.filterEqStatisticsdefectssystemIssuesi001, "form", "")
	}
	if r.filterEqHasStats != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.hasStats", r.filterEqHasStats, "form", "")
	}
	if r.filterEqStatisticsexecutionstotal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$total", r.filterEqStatisticsexecutionstotal, "form", "")
	}
	if r.filterEqStatisticsexecutionsskipped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$skipped", r.filterEqStatisticsexecutionsskipped, "form", "")
	}
	if r.filterEqLastModified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.lastModified", r.filterEqLastModified, "form", "")
	}
	if r.filterEqStatisticsdefectsproductBugpb001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$product_bug$pb001", r.filterEqStatisticsdefectsproductBugpb001, "form", "")
	}
	if r.filterEqStatisticsdefectsautomationBugab001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$automation_bug$ab001", r.filterEqStatisticsdefectsautomationBugab001, "form", "")
	}
	if r.filterEqType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.type", r.filterEqType, "form", "")
	}
	if r.filterEqIssueId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.issueId", r.filterEqIssueId, "form", "")
	}
	if r.filterEqMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.mode", r.filterEqMode, "form", "")
	}
	if r.filterEqTestCaseId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.testCaseId", r.filterEqTestCaseId, "form", "")
	}
	if r.filterEqUniqueId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.uniqueId", r.filterEqUniqueId, "form", "")
	}
	if r.filterHasCompositeSystemAttribute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.has.compositeSystemAttribute", r.filterHasCompositeSystemAttribute, "form", "")
	}
	if r.filterEqProjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.projectId", r.filterEqProjectId, "form", "")
	}
	if r.filterEqIssueComment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.issueComment", r.filterEqIssueComment, "form", "")
	}
	if r.filterEqIgnoreAnalyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.ignoreAnalyzer", r.filterEqIgnoreAnalyzer, "form", "")
	}
	if r.filterEqLaunchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.launchId", r.filterEqLaunchId, "form", "")
	}
	if r.filterEqStatisticsdefectsnoDefectnd001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$no_defect$nd001", r.filterEqStatisticsdefectsnoDefectnd001, "form", "")
	}
	if r.filterEqHasChildren != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.hasChildren", r.filterEqHasChildren, "form", "")
	}
	if r.filterEqPatternName != nil {
		t := *r.filterEqPatternName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.patternName", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.patternName", t, "form", "multi")
		}
	}
	if r.filterEqRetryParentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.retryParentId", r.filterEqRetryParentId, "form", "")
	}
	if r.filterEqTicketId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.ticketId", r.filterEqTicketId, "form", "")
	}
	if r.filterEqAttributeKey != nil {
		t := *r.filterEqAttributeKey
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeKey", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeKey", t, "form", "multi")
		}
	}
	if r.filterEqKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.key", r.filterEqKey, "form", "")
	}
	if r.filterEqParentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.parentId", r.filterEqParentId, "form", "")
	}
	if r.filterEqStatisticsdefectstoInvestigateti001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$to_investigate$ti001", r.filterEqStatisticsdefectstoInvestigateti001, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTestItems2Request struct {
	ctx                         context.Context
	ApiService                  *TestItemAPIService
	projectName                 string
	filterCntName               *string
	filterHasCompositeAttribute *string
	filterInStatus              *string
	pagePage                    *int32
	pageSize                    *int32
	pageSort                    *string
}

func (r ApiGetTestItems2Request) FilterCntName(filterCntName string) ApiGetTestItems2Request {
	r.filterCntName = &filterCntName
	return r
}

func (r ApiGetTestItems2Request) FilterHasCompositeAttribute(filterHasCompositeAttribute string) ApiGetTestItems2Request {
	r.filterHasCompositeAttribute = &filterHasCompositeAttribute
	return r
}

func (r ApiGetTestItems2Request) FilterInStatus(filterInStatus string) ApiGetTestItems2Request {
	r.filterInStatus = &filterInStatus
	return r
}

// Results page you want to retrieve (0..N)
func (r ApiGetTestItems2Request) PagePage(pagePage int32) ApiGetTestItems2Request {
	r.pagePage = &pagePage
	return r
}

// Number of records per page
func (r ApiGetTestItems2Request) PageSize(pageSize int32) ApiGetTestItems2Request {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetTestItems2Request) PageSort(pageSort string) ApiGetTestItems2Request {
	r.pageSort = &pageSort
	return r
}

func (r ApiGetTestItems2Request) Execute() (*PageTestItemResource, *http.Response, error) {
	return r.ApiService.GetTestItems2Execute(r)
}

/*
GetTestItems2 Search test items by either name or attribute

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetTestItems2Request
*/
func (a *TestItemAPIService) GetTestItems2(ctx context.Context, projectName string) ApiGetTestItems2Request {
	return ApiGetTestItems2Request{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return PageTestItemResource
func (a *TestItemAPIService) GetTestItems2Execute(r ApiGetTestItems2Request) (*PageTestItemResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageTestItemResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.GetTestItems2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/search"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterCntName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.cnt.name", r.filterCntName, "form", "")
	}
	if r.filterHasCompositeAttribute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.has.compositeAttribute", r.filterHasCompositeAttribute, "form", "")
	}
	if r.filterInStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.in.status", r.filterInStatus, "form", "")
	}
	if r.pagePage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.page", r.pagePage, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.sort", r.pageSort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTestItems3Request struct {
	ctx         context.Context
	ApiService  *TestItemAPIService
	ids         *[]int64
	projectName string
}

func (r ApiGetTestItems3Request) Ids(ids []int64) ApiGetTestItems3Request {
	r.ids = &ids
	return r
}

func (r ApiGetTestItems3Request) Execute() ([]TestItemResource, *http.Response, error) {
	return r.ApiService.GetTestItems3Execute(r)
}

/*
GetTestItems3 Get test items by specified ids

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetTestItems3Request
*/
func (a *TestItemAPIService) GetTestItems3(ctx context.Context, projectName string) ApiGetTestItems3Request {
	return ApiGetTestItems3Request{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []TestItemResource
func (a *TestItemAPIService) GetTestItems3Execute(r ApiGetTestItems3Request) ([]TestItemResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []TestItemResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.GetTestItems3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/items"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	{
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTestItemsV2Request struct {
	ctx                                         context.Context
	ApiService                                  *TestItemAPIService
	params                                      *map[string]string
	projectName                                 string
	filterEqUuid                                *string
	filterEqAttributeValue                      *[]interface{}
	filterEqLevelAttribute                      *[]interface{}
	filterEqId                                  *int32
	filterEqStatus                              *string
	filterEqStartTime                           *string
	filterEqIssueType                           *string
	filterEqClusterId                           *int32
	filterEqPath                                *int32
	filterEqIssueGroupId                        *string
	filterEqHasRetries                          *bool
	filterEqIssueTypeId                         *int32
	filterEqValue                               *string
	filterEqDuration                            *int32
	filterHasCompositeAttribute                 *string
	filterEqEndTime                             *string
	filterEqStatisticsexecutionspassed          *int32
	filterEqName                                *string
	filterEqAutoAnalyzed                        *bool
	filterEqLocator                             *string
	filterEqDescription                         *string
	filterEqStatisticsexecutionsfailed          *int32
	filterEqTestCaseHash                        *int32
	filterEqStatisticsdefectssystemIssuesi001   *int32
	filterEqHasStats                            *bool
	filterEqStatisticsexecutionstotal           *int32
	filterEqStatisticsexecutionsskipped         *int32
	filterEqLastModified                        *string
	filterEqStatisticsdefectsproductBugpb001    *int32
	filterEqStatisticsdefectsautomationBugab001 *int32
	filterEqType                                *string
	filterEqIssueId                             *int32
	filterEqMode                                *string
	filterEqTestCaseId                          *string
	filterEqUniqueId                            *string
	filterHasCompositeSystemAttribute           *string
	filterEqProjectId                           *int32
	filterEqIssueComment                        *string
	filterEqIgnoreAnalyzer                      *bool
	filterEqLaunchId                            *int32
	filterEqStatisticsdefectsnoDefectnd001      *int32
	filterEqHasChildren                         *bool
	filterEqPatternName                         *[]interface{}
	filterEqRetryParentId                       *int32
	filterEqTicketId                            *string
	filterEqAttributeKey                        *[]interface{}
	filterEqKey                                 *string
	filterEqParentId                            *int32
	filterEqStatisticsdefectstoInvestigateti001 *int32
	pagePage                                    *int32
	pageSize                                    *int32
	pageSort                                    *string
}

func (r ApiGetTestItemsV2Request) Params(params map[string]string) ApiGetTestItemsV2Request {
	r.params = &params
	return r
}

// Filters by &#39;uuid&#39;
func (r ApiGetTestItemsV2Request) FilterEqUuid(filterEqUuid string) ApiGetTestItemsV2Request {
	r.filterEqUuid = &filterEqUuid
	return r
}

// Filters by &#39;attributeValue&#39;
func (r ApiGetTestItemsV2Request) FilterEqAttributeValue(filterEqAttributeValue []interface{}) ApiGetTestItemsV2Request {
	r.filterEqAttributeValue = &filterEqAttributeValue
	return r
}

// Filters by &#39;levelAttribute&#39;
func (r ApiGetTestItemsV2Request) FilterEqLevelAttribute(filterEqLevelAttribute []interface{}) ApiGetTestItemsV2Request {
	r.filterEqLevelAttribute = &filterEqLevelAttribute
	return r
}

// Filters by &#39;id&#39;
func (r ApiGetTestItemsV2Request) FilterEqId(filterEqId int32) ApiGetTestItemsV2Request {
	r.filterEqId = &filterEqId
	return r
}

// Filters by &#39;status&#39;
func (r ApiGetTestItemsV2Request) FilterEqStatus(filterEqStatus string) ApiGetTestItemsV2Request {
	r.filterEqStatus = &filterEqStatus
	return r
}

// Filters by &#39;startTime&#39;
func (r ApiGetTestItemsV2Request) FilterEqStartTime(filterEqStartTime string) ApiGetTestItemsV2Request {
	r.filterEqStartTime = &filterEqStartTime
	return r
}

// Filters by &#39;issueType&#39;
func (r ApiGetTestItemsV2Request) FilterEqIssueType(filterEqIssueType string) ApiGetTestItemsV2Request {
	r.filterEqIssueType = &filterEqIssueType
	return r
}

// Filters by &#39;clusterId&#39;
func (r ApiGetTestItemsV2Request) FilterEqClusterId(filterEqClusterId int32) ApiGetTestItemsV2Request {
	r.filterEqClusterId = &filterEqClusterId
	return r
}

// Filters by &#39;path&#39;
func (r ApiGetTestItemsV2Request) FilterEqPath(filterEqPath int32) ApiGetTestItemsV2Request {
	r.filterEqPath = &filterEqPath
	return r
}

// Filters by &#39;issueGroupId&#39;
func (r ApiGetTestItemsV2Request) FilterEqIssueGroupId(filterEqIssueGroupId string) ApiGetTestItemsV2Request {
	r.filterEqIssueGroupId = &filterEqIssueGroupId
	return r
}

// Filters by &#39;hasRetries&#39;
func (r ApiGetTestItemsV2Request) FilterEqHasRetries(filterEqHasRetries bool) ApiGetTestItemsV2Request {
	r.filterEqHasRetries = &filterEqHasRetries
	return r
}

// Filters by &#39;issueTypeId&#39;
func (r ApiGetTestItemsV2Request) FilterEqIssueTypeId(filterEqIssueTypeId int32) ApiGetTestItemsV2Request {
	r.filterEqIssueTypeId = &filterEqIssueTypeId
	return r
}

// Filters by &#39;value&#39;
func (r ApiGetTestItemsV2Request) FilterEqValue(filterEqValue string) ApiGetTestItemsV2Request {
	r.filterEqValue = &filterEqValue
	return r
}

// Filters by &#39;duration&#39;
func (r ApiGetTestItemsV2Request) FilterEqDuration(filterEqDuration int32) ApiGetTestItemsV2Request {
	r.filterEqDuration = &filterEqDuration
	return r
}

// Filters by &#39;compositeAttribute&#39;
func (r ApiGetTestItemsV2Request) FilterHasCompositeAttribute(filterHasCompositeAttribute string) ApiGetTestItemsV2Request {
	r.filterHasCompositeAttribute = &filterHasCompositeAttribute
	return r
}

// Filters by &#39;endTime&#39;
func (r ApiGetTestItemsV2Request) FilterEqEndTime(filterEqEndTime string) ApiGetTestItemsV2Request {
	r.filterEqEndTime = &filterEqEndTime
	return r
}

// Filters by &#39;statistics$executions$passed&#39;
func (r ApiGetTestItemsV2Request) FilterEqStatisticsexecutionspassed(filterEqStatisticsexecutionspassed int32) ApiGetTestItemsV2Request {
	r.filterEqStatisticsexecutionspassed = &filterEqStatisticsexecutionspassed
	return r
}

// Filters by &#39;name&#39;
func (r ApiGetTestItemsV2Request) FilterEqName(filterEqName string) ApiGetTestItemsV2Request {
	r.filterEqName = &filterEqName
	return r
}

// Filters by &#39;autoAnalyzed&#39;
func (r ApiGetTestItemsV2Request) FilterEqAutoAnalyzed(filterEqAutoAnalyzed bool) ApiGetTestItemsV2Request {
	r.filterEqAutoAnalyzed = &filterEqAutoAnalyzed
	return r
}

// Filters by &#39;locator&#39;
func (r ApiGetTestItemsV2Request) FilterEqLocator(filterEqLocator string) ApiGetTestItemsV2Request {
	r.filterEqLocator = &filterEqLocator
	return r
}

// Filters by &#39;description&#39;
func (r ApiGetTestItemsV2Request) FilterEqDescription(filterEqDescription string) ApiGetTestItemsV2Request {
	r.filterEqDescription = &filterEqDescription
	return r
}

// Filters by &#39;statistics$executions$failed&#39;
func (r ApiGetTestItemsV2Request) FilterEqStatisticsexecutionsfailed(filterEqStatisticsexecutionsfailed int32) ApiGetTestItemsV2Request {
	r.filterEqStatisticsexecutionsfailed = &filterEqStatisticsexecutionsfailed
	return r
}

// Filters by &#39;testCaseHash&#39;
func (r ApiGetTestItemsV2Request) FilterEqTestCaseHash(filterEqTestCaseHash int32) ApiGetTestItemsV2Request {
	r.filterEqTestCaseHash = &filterEqTestCaseHash
	return r
}

// Filters by &#39;statistics$defects$system_issue$si001&#39;
func (r ApiGetTestItemsV2Request) FilterEqStatisticsdefectssystemIssuesi001(filterEqStatisticsdefectssystemIssuesi001 int32) ApiGetTestItemsV2Request {
	r.filterEqStatisticsdefectssystemIssuesi001 = &filterEqStatisticsdefectssystemIssuesi001
	return r
}

// Filters by &#39;hasStats&#39;
func (r ApiGetTestItemsV2Request) FilterEqHasStats(filterEqHasStats bool) ApiGetTestItemsV2Request {
	r.filterEqHasStats = &filterEqHasStats
	return r
}

// Filters by &#39;statistics$executions$total&#39;
func (r ApiGetTestItemsV2Request) FilterEqStatisticsexecutionstotal(filterEqStatisticsexecutionstotal int32) ApiGetTestItemsV2Request {
	r.filterEqStatisticsexecutionstotal = &filterEqStatisticsexecutionstotal
	return r
}

// Filters by &#39;statistics$executions$skipped&#39;
func (r ApiGetTestItemsV2Request) FilterEqStatisticsexecutionsskipped(filterEqStatisticsexecutionsskipped int32) ApiGetTestItemsV2Request {
	r.filterEqStatisticsexecutionsskipped = &filterEqStatisticsexecutionsskipped
	return r
}

// Filters by &#39;lastModified&#39;
func (r ApiGetTestItemsV2Request) FilterEqLastModified(filterEqLastModified string) ApiGetTestItemsV2Request {
	r.filterEqLastModified = &filterEqLastModified
	return r
}

// Filters by &#39;statistics$defects$product_bug$pb001&#39;
func (r ApiGetTestItemsV2Request) FilterEqStatisticsdefectsproductBugpb001(filterEqStatisticsdefectsproductBugpb001 int32) ApiGetTestItemsV2Request {
	r.filterEqStatisticsdefectsproductBugpb001 = &filterEqStatisticsdefectsproductBugpb001
	return r
}

// Filters by &#39;statistics$defects$automation_bug$ab001&#39;
func (r ApiGetTestItemsV2Request) FilterEqStatisticsdefectsautomationBugab001(filterEqStatisticsdefectsautomationBugab001 int32) ApiGetTestItemsV2Request {
	r.filterEqStatisticsdefectsautomationBugab001 = &filterEqStatisticsdefectsautomationBugab001
	return r
}

// Filters by &#39;type&#39;
func (r ApiGetTestItemsV2Request) FilterEqType(filterEqType string) ApiGetTestItemsV2Request {
	r.filterEqType = &filterEqType
	return r
}

// Filters by &#39;issueId&#39;
func (r ApiGetTestItemsV2Request) FilterEqIssueId(filterEqIssueId int32) ApiGetTestItemsV2Request {
	r.filterEqIssueId = &filterEqIssueId
	return r
}

// Filters by &#39;mode&#39;
func (r ApiGetTestItemsV2Request) FilterEqMode(filterEqMode string) ApiGetTestItemsV2Request {
	r.filterEqMode = &filterEqMode
	return r
}

// Filters by &#39;testCaseId&#39;
func (r ApiGetTestItemsV2Request) FilterEqTestCaseId(filterEqTestCaseId string) ApiGetTestItemsV2Request {
	r.filterEqTestCaseId = &filterEqTestCaseId
	return r
}

// Filters by &#39;uniqueId&#39;
func (r ApiGetTestItemsV2Request) FilterEqUniqueId(filterEqUniqueId string) ApiGetTestItemsV2Request {
	r.filterEqUniqueId = &filterEqUniqueId
	return r
}

// Filters by &#39;compositeSystemAttribute&#39;
func (r ApiGetTestItemsV2Request) FilterHasCompositeSystemAttribute(filterHasCompositeSystemAttribute string) ApiGetTestItemsV2Request {
	r.filterHasCompositeSystemAttribute = &filterHasCompositeSystemAttribute
	return r
}

// Filters by &#39;projectId&#39;
func (r ApiGetTestItemsV2Request) FilterEqProjectId(filterEqProjectId int32) ApiGetTestItemsV2Request {
	r.filterEqProjectId = &filterEqProjectId
	return r
}

// Filters by &#39;issueComment&#39;
func (r ApiGetTestItemsV2Request) FilterEqIssueComment(filterEqIssueComment string) ApiGetTestItemsV2Request {
	r.filterEqIssueComment = &filterEqIssueComment
	return r
}

// Filters by &#39;ignoreAnalyzer&#39;
func (r ApiGetTestItemsV2Request) FilterEqIgnoreAnalyzer(filterEqIgnoreAnalyzer bool) ApiGetTestItemsV2Request {
	r.filterEqIgnoreAnalyzer = &filterEqIgnoreAnalyzer
	return r
}

// Filters by &#39;launchId&#39;
func (r ApiGetTestItemsV2Request) FilterEqLaunchId(filterEqLaunchId int32) ApiGetTestItemsV2Request {
	r.filterEqLaunchId = &filterEqLaunchId
	return r
}

// Filters by &#39;statistics$defects$no_defect$nd001&#39;
func (r ApiGetTestItemsV2Request) FilterEqStatisticsdefectsnoDefectnd001(filterEqStatisticsdefectsnoDefectnd001 int32) ApiGetTestItemsV2Request {
	r.filterEqStatisticsdefectsnoDefectnd001 = &filterEqStatisticsdefectsnoDefectnd001
	return r
}

// Filters by &#39;hasChildren&#39;
func (r ApiGetTestItemsV2Request) FilterEqHasChildren(filterEqHasChildren bool) ApiGetTestItemsV2Request {
	r.filterEqHasChildren = &filterEqHasChildren
	return r
}

// Filters by &#39;patternName&#39;
func (r ApiGetTestItemsV2Request) FilterEqPatternName(filterEqPatternName []interface{}) ApiGetTestItemsV2Request {
	r.filterEqPatternName = &filterEqPatternName
	return r
}

// Filters by &#39;retryParentId&#39;
func (r ApiGetTestItemsV2Request) FilterEqRetryParentId(filterEqRetryParentId int32) ApiGetTestItemsV2Request {
	r.filterEqRetryParentId = &filterEqRetryParentId
	return r
}

// Filters by &#39;ticketId&#39;
func (r ApiGetTestItemsV2Request) FilterEqTicketId(filterEqTicketId string) ApiGetTestItemsV2Request {
	r.filterEqTicketId = &filterEqTicketId
	return r
}

// Filters by &#39;attributeKey&#39;
func (r ApiGetTestItemsV2Request) FilterEqAttributeKey(filterEqAttributeKey []interface{}) ApiGetTestItemsV2Request {
	r.filterEqAttributeKey = &filterEqAttributeKey
	return r
}

// Filters by &#39;key&#39;
func (r ApiGetTestItemsV2Request) FilterEqKey(filterEqKey string) ApiGetTestItemsV2Request {
	r.filterEqKey = &filterEqKey
	return r
}

// Filters by &#39;parentId&#39;
func (r ApiGetTestItemsV2Request) FilterEqParentId(filterEqParentId int32) ApiGetTestItemsV2Request {
	r.filterEqParentId = &filterEqParentId
	return r
}

// Filters by &#39;statistics$defects$to_investigate$ti001&#39;
func (r ApiGetTestItemsV2Request) FilterEqStatisticsdefectstoInvestigateti001(filterEqStatisticsdefectstoInvestigateti001 int32) ApiGetTestItemsV2Request {
	r.filterEqStatisticsdefectstoInvestigateti001 = &filterEqStatisticsdefectstoInvestigateti001
	return r
}

// Results page you want to retrieve (0..N)
func (r ApiGetTestItemsV2Request) PagePage(pagePage int32) ApiGetTestItemsV2Request {
	r.pagePage = &pagePage
	return r
}

// Number of records per page
func (r ApiGetTestItemsV2Request) PageSize(pageSize int32) ApiGetTestItemsV2Request {
	r.pageSize = &pageSize
	return r
}

// Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetTestItemsV2Request) PageSort(pageSort string) ApiGetTestItemsV2Request {
	r.pageSort = &pageSort
	return r
}

func (r ApiGetTestItemsV2Request) Execute() (*PageTestItemResource, *http.Response, error) {
	return r.ApiService.GetTestItemsV2Execute(r)
}

/*
GetTestItemsV2 Find test items by specified filter

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetTestItemsV2Request
*/
func (a *TestItemAPIService) GetTestItemsV2(ctx context.Context, projectName string) ApiGetTestItemsV2Request {
	return ApiGetTestItemsV2Request{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return PageTestItemResource
func (a *TestItemAPIService) GetTestItemsV2Execute(r ApiGetTestItemsV2Request) (*PageTestItemResource, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PageTestItemResource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.GetTestItemsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/v2"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.params == nil {
		return localVarReturnValue, nil, reportError("params is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	if r.filterEqUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.uuid", r.filterEqUuid, "form", "")
	}
	if r.filterEqAttributeValue != nil {
		t := *r.filterEqAttributeValue
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeValue", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeValue", t, "form", "multi")
		}
	}
	if r.filterEqLevelAttribute != nil {
		t := *r.filterEqLevelAttribute
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.levelAttribute", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.levelAttribute", t, "form", "multi")
		}
	}
	if r.filterEqId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.id", r.filterEqId, "form", "")
	}
	if r.filterEqStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.status", r.filterEqStatus, "form", "")
	}
	if r.filterEqStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.startTime", r.filterEqStartTime, "form", "")
	}
	if r.filterEqIssueType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.issueType", r.filterEqIssueType, "form", "")
	}
	if r.filterEqClusterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.clusterId", r.filterEqClusterId, "form", "")
	}
	if r.filterEqPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.path", r.filterEqPath, "form", "")
	}
	if r.filterEqIssueGroupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.issueGroupId", r.filterEqIssueGroupId, "form", "")
	}
	if r.filterEqHasRetries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.hasRetries", r.filterEqHasRetries, "form", "")
	}
	if r.filterEqIssueTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.issueTypeId", r.filterEqIssueTypeId, "form", "")
	}
	if r.filterEqValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.value", r.filterEqValue, "form", "")
	}
	if r.filterEqDuration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.duration", r.filterEqDuration, "form", "")
	}
	if r.filterHasCompositeAttribute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.has.compositeAttribute", r.filterHasCompositeAttribute, "form", "")
	}
	if r.filterEqEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.endTime", r.filterEqEndTime, "form", "")
	}
	if r.filterEqStatisticsexecutionspassed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$passed", r.filterEqStatisticsexecutionspassed, "form", "")
	}
	if r.filterEqName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.name", r.filterEqName, "form", "")
	}
	if r.filterEqAutoAnalyzed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.autoAnalyzed", r.filterEqAutoAnalyzed, "form", "")
	}
	if r.filterEqLocator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.locator", r.filterEqLocator, "form", "")
	}
	if r.filterEqDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.description", r.filterEqDescription, "form", "")
	}
	if r.filterEqStatisticsexecutionsfailed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$failed", r.filterEqStatisticsexecutionsfailed, "form", "")
	}
	if r.filterEqTestCaseHash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.testCaseHash", r.filterEqTestCaseHash, "form", "")
	}
	if r.filterEqStatisticsdefectssystemIssuesi001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$system_issue$si001", r.filterEqStatisticsdefectssystemIssuesi001, "form", "")
	}
	if r.filterEqHasStats != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.hasStats", r.filterEqHasStats, "form", "")
	}
	if r.filterEqStatisticsexecutionstotal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$total", r.filterEqStatisticsexecutionstotal, "form", "")
	}
	if r.filterEqStatisticsexecutionsskipped != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$executions$skipped", r.filterEqStatisticsexecutionsskipped, "form", "")
	}
	if r.filterEqLastModified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.lastModified", r.filterEqLastModified, "form", "")
	}
	if r.filterEqStatisticsdefectsproductBugpb001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$product_bug$pb001", r.filterEqStatisticsdefectsproductBugpb001, "form", "")
	}
	if r.filterEqStatisticsdefectsautomationBugab001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$automation_bug$ab001", r.filterEqStatisticsdefectsautomationBugab001, "form", "")
	}
	if r.filterEqType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.type", r.filterEqType, "form", "")
	}
	if r.filterEqIssueId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.issueId", r.filterEqIssueId, "form", "")
	}
	if r.filterEqMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.mode", r.filterEqMode, "form", "")
	}
	if r.filterEqTestCaseId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.testCaseId", r.filterEqTestCaseId, "form", "")
	}
	if r.filterEqUniqueId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.uniqueId", r.filterEqUniqueId, "form", "")
	}
	if r.filterHasCompositeSystemAttribute != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.has.compositeSystemAttribute", r.filterHasCompositeSystemAttribute, "form", "")
	}
	if r.filterEqProjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.projectId", r.filterEqProjectId, "form", "")
	}
	if r.filterEqIssueComment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.issueComment", r.filterEqIssueComment, "form", "")
	}
	if r.filterEqIgnoreAnalyzer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.ignoreAnalyzer", r.filterEqIgnoreAnalyzer, "form", "")
	}
	if r.filterEqLaunchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.launchId", r.filterEqLaunchId, "form", "")
	}
	if r.filterEqStatisticsdefectsnoDefectnd001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$no_defect$nd001", r.filterEqStatisticsdefectsnoDefectnd001, "form", "")
	}
	if r.filterEqHasChildren != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.hasChildren", r.filterEqHasChildren, "form", "")
	}
	if r.filterEqPatternName != nil {
		t := *r.filterEqPatternName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.patternName", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.patternName", t, "form", "multi")
		}
	}
	if r.filterEqRetryParentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.retryParentId", r.filterEqRetryParentId, "form", "")
	}
	if r.filterEqTicketId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.ticketId", r.filterEqTicketId, "form", "")
	}
	if r.filterEqAttributeKey != nil {
		t := *r.filterEqAttributeKey
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeKey", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.attributeKey", t, "form", "multi")
		}
	}
	if r.filterEqKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.key", r.filterEqKey, "form", "")
	}
	if r.filterEqParentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.parentId", r.filterEqParentId, "form", "")
	}
	if r.filterEqStatisticsdefectstoInvestigateti001 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter.eq.statistics$defects$to_investigate$ti001", r.filterEqStatisticsdefectstoInvestigateti001, "form", "")
	}
	if r.pagePage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.page", r.pagePage, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.size", r.pageSize, "form", "")
	}
	if r.pageSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page.sort", r.pageSort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTicketIdsRequest struct {
	ctx         context.Context
	ApiService  *TestItemAPIService
	launch      *int64
	projectName string
	term        *string
}

func (r ApiGetTicketIdsRequest) Launch(launch int64) ApiGetTicketIdsRequest {
	r.launch = &launch
	return r
}

func (r ApiGetTicketIdsRequest) Term(term string) ApiGetTicketIdsRequest {
	r.term = &term
	return r
}

func (r ApiGetTicketIdsRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetTicketIdsExecute(r)
}

/*
GetTicketIds Get tickets that contains a term as a part inside for specified launch

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetTicketIdsRequest
*/
func (a *TestItemAPIService) GetTicketIds(ctx context.Context, projectName string) ApiGetTicketIdsRequest {
	return ApiGetTicketIdsRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []string
func (a *TestItemAPIService) GetTicketIdsExecute(r ApiGetTicketIdsRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.GetTicketIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/ticket/ids"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.launch == nil {
		return localVarReturnValue, nil, reportError("launch is required and must be specified")
	}
	if r.term == nil {
		return localVarReturnValue, nil, reportError("term is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "launch", r.launch, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "term", r.term, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTicketIdsForProjectRequest struct {
	ctx         context.Context
	ApiService  *TestItemAPIService
	projectName string
	term        *string
}

func (r ApiGetTicketIdsForProjectRequest) Term(term string) ApiGetTicketIdsForProjectRequest {
	r.term = &term
	return r
}

func (r ApiGetTicketIdsForProjectRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetTicketIdsForProjectExecute(r)
}

/*
GetTicketIdsForProject Get tickets that contains a term as a part inside for specified launch

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetTicketIdsForProjectRequest
*/
func (a *TestItemAPIService) GetTicketIdsForProject(ctx context.Context, projectName string) ApiGetTicketIdsForProjectRequest {
	return ApiGetTicketIdsForProjectRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []string
func (a *TestItemAPIService) GetTicketIdsForProjectExecute(r ApiGetTicketIdsForProjectRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.GetTicketIdsForProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/ticket/ids/all"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.term == nil {
		return localVarReturnValue, nil, reportError("term is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "term", r.term, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUniqueAttributeKeysRequest struct {
	ctx                   context.Context
	ApiService            *TestItemAPIService
	filterCntAttributeKey *string
	projectName           string
	launch                *int64
}

func (r ApiGetUniqueAttributeKeysRequest) FilterCntAttributeKey(filterCntAttributeKey string) ApiGetUniqueAttributeKeysRequest {
	r.filterCntAttributeKey = &filterCntAttributeKey
	return r
}

func (r ApiGetUniqueAttributeKeysRequest) Launch(launch int64) ApiGetUniqueAttributeKeysRequest {
	r.launch = &launch
	return r
}

func (r ApiGetUniqueAttributeKeysRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetUniqueAttributeKeysExecute(r)
}

/*
GetUniqueAttributeKeys Get all unique attribute keys on the project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiGetUniqueAttributeKeysRequest
*/
func (a *TestItemAPIService) GetUniqueAttributeKeys(ctx context.Context, projectName string) ApiGetUniqueAttributeKeysRequest {
	return ApiGetUniqueAttributeKeysRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []string
func (a *TestItemAPIService) GetUniqueAttributeKeysExecute(r ApiGetUniqueAttributeKeysRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.GetUniqueAttributeKeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/attribute/keys"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.filterCntAttributeKey == nil {
		return localVarReturnValue, nil, reportError("filterCntAttributeKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "filter.cnt.attributeKey", r.filterCntAttributeKey, "form", "")
	if r.launch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "launch", r.launch, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHandleSuggestChooseRequest struct {
	ctx         context.Context
	ApiService  *TestItemAPIService
	projectName string
	suggestInfo *[]SuggestInfo
}

func (r ApiHandleSuggestChooseRequest) SuggestInfo(suggestInfo []SuggestInfo) ApiHandleSuggestChooseRequest {
	r.suggestInfo = &suggestInfo
	return r
}

func (r ApiHandleSuggestChooseRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.HandleSuggestChooseExecute(r)
}

/*
HandleSuggestChoose Handle user choice from suggested items

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiHandleSuggestChooseRequest
*/
func (a *TestItemAPIService) HandleSuggestChoose(ctx context.Context, projectName string) ApiHandleSuggestChooseRequest {
	return ApiHandleSuggestChooseRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *TestItemAPIService) HandleSuggestChooseExecute(r ApiHandleSuggestChooseRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.HandleSuggestChoose")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/suggest/choice"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.suggestInfo == nil {
		return localVarReturnValue, nil, reportError("suggestInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.suggestInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLinkExternalIssuesRequest struct {
	ctx                 context.Context
	ApiService          *TestItemAPIService
	projectName         string
	linkExternalIssueRQ *LinkExternalIssueRQ
}

func (r ApiLinkExternalIssuesRequest) LinkExternalIssueRQ(linkExternalIssueRQ LinkExternalIssueRQ) ApiLinkExternalIssuesRequest {
	r.linkExternalIssueRQ = &linkExternalIssueRQ
	return r
}

func (r ApiLinkExternalIssuesRequest) Execute() ([]OperationCompletionRS, *http.Response, error) {
	return r.ApiService.LinkExternalIssuesExecute(r)
}

/*
LinkExternalIssues Attach external issue for specified test items

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiLinkExternalIssuesRequest
*/
func (a *TestItemAPIService) LinkExternalIssues(ctx context.Context, projectName string) ApiLinkExternalIssuesRequest {
	return ApiLinkExternalIssuesRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []OperationCompletionRS
func (a *TestItemAPIService) LinkExternalIssuesExecute(r ApiLinkExternalIssuesRequest) ([]OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.LinkExternalIssues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/issue/link"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.linkExternalIssueRQ == nil {
		return localVarReturnValue, nil, reportError("linkExternalIssueRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.linkExternalIssueRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartChildItem2Request struct {
	ctx             context.Context
	ApiService      *TestItemAPIService
	parentItem      string
	projectName     string
	startTestItemRQ *StartTestItemRQ
}

func (r ApiStartChildItem2Request) StartTestItemRQ(startTestItemRQ StartTestItemRQ) ApiStartChildItem2Request {
	r.startTestItemRQ = &startTestItemRQ
	return r
}

func (r ApiStartChildItem2Request) Execute() (*EntryCreatedAsyncRS, *http.Response, error) {
	return r.ApiService.StartChildItem2Execute(r)
}

/*
StartChildItem2 Start a child test item

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param parentItem
	@param projectName
	@return ApiStartChildItem2Request
*/
func (a *TestItemAPIService) StartChildItem2(ctx context.Context, parentItem, projectName string) ApiStartChildItem2Request {
	return ApiStartChildItem2Request{
		ApiService:  a,
		ctx:         ctx,
		parentItem:  parentItem,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return EntryCreatedAsyncRS
func (a *TestItemAPIService) StartChildItem2Execute(r ApiStartChildItem2Request) (*EntryCreatedAsyncRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EntryCreatedAsyncRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.StartChildItem2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/{parentItem}"
	localVarPath = strings.Replace(localVarPath, "{"+"parentItem"+"}", url.PathEscape(parameterValueToString(r.parentItem, "parentItem")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTestItemRQ == nil {
		return localVarReturnValue, nil, reportError("startTestItemRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startTestItemRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartChildItem3Request struct {
	ctx             context.Context
	ApiService      *TestItemAPIService
	parentItem      string
	projectName     string
	startTestItemRQ *StartTestItemRQ
}

func (r ApiStartChildItem3Request) StartTestItemRQ(startTestItemRQ StartTestItemRQ) ApiStartChildItem3Request {
	r.startTestItemRQ = &startTestItemRQ
	return r
}

func (r ApiStartChildItem3Request) Execute() (*EntryCreatedAsyncRS, *http.Response, error) {
	return r.ApiService.StartChildItem3Execute(r)
}

/*
StartChildItem3 Start a child test item

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param parentItem
	@param projectName
	@return ApiStartChildItem3Request
*/
func (a *TestItemAPIService) StartChildItem3(ctx context.Context, parentItem, projectName string) ApiStartChildItem3Request {
	return ApiStartChildItem3Request{
		ApiService:  a,
		ctx:         ctx,
		parentItem:  parentItem,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return EntryCreatedAsyncRS
func (a *TestItemAPIService) StartChildItem3Execute(r ApiStartChildItem3Request) (*EntryCreatedAsyncRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EntryCreatedAsyncRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.StartChildItem3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/{parentItem}/"
	localVarPath = strings.Replace(localVarPath, "{"+"parentItem"+"}", url.PathEscape(parameterValueToString(r.parentItem, "parentItem")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTestItemRQ == nil {
		return localVarReturnValue, nil, reportError("startTestItemRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startTestItemRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartRootItemRequest struct {
	ctx             context.Context
	ApiService      *TestItemAPIService
	projectName     string
	startTestItemRQ *StartTestItemRQ
}

func (r ApiStartRootItemRequest) StartTestItemRQ(startTestItemRQ StartTestItemRQ) ApiStartRootItemRequest {
	r.startTestItemRQ = &startTestItemRQ
	return r
}

func (r ApiStartRootItemRequest) Execute() (*EntryCreatedAsyncRS, *http.Response, error) {
	return r.ApiService.StartRootItemExecute(r)
}

/*
StartRootItem Start a root test item

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiStartRootItemRequest
*/
func (a *TestItemAPIService) StartRootItem(ctx context.Context, projectName string) ApiStartRootItemRequest {
	return ApiStartRootItemRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return EntryCreatedAsyncRS
func (a *TestItemAPIService) StartRootItemExecute(r ApiStartRootItemRequest) (*EntryCreatedAsyncRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EntryCreatedAsyncRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.StartRootItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTestItemRQ == nil {
		return localVarReturnValue, nil, reportError("startTestItemRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startTestItemRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartRootItem3Request struct {
	ctx             context.Context
	ApiService      *TestItemAPIService
	projectName     string
	startTestItemRQ *StartTestItemRQ
}

func (r ApiStartRootItem3Request) StartTestItemRQ(startTestItemRQ StartTestItemRQ) ApiStartRootItem3Request {
	r.startTestItemRQ = &startTestItemRQ
	return r
}

func (r ApiStartRootItem3Request) Execute() (*EntryCreatedAsyncRS, *http.Response, error) {
	return r.ApiService.StartRootItem3Execute(r)
}

/*
StartRootItem3 Start a root test item

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiStartRootItem3Request
*/
func (a *TestItemAPIService) StartRootItem3(ctx context.Context, projectName string) ApiStartRootItem3Request {
	return ApiStartRootItem3Request{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return EntryCreatedAsyncRS
func (a *TestItemAPIService) StartRootItem3Execute(r ApiStartRootItem3Request) (*EntryCreatedAsyncRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EntryCreatedAsyncRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.StartRootItem3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTestItemRQ == nil {
		return localVarReturnValue, nil, reportError("startTestItemRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startTestItemRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnlinkExternalIssuesRequest struct {
	ctx                   context.Context
	ApiService            *TestItemAPIService
	projectName           string
	unlinkExternalIssueRQ *UnlinkExternalIssueRQ
}

func (r ApiUnlinkExternalIssuesRequest) UnlinkExternalIssueRQ(unlinkExternalIssueRQ UnlinkExternalIssueRQ) ApiUnlinkExternalIssuesRequest {
	r.unlinkExternalIssueRQ = &unlinkExternalIssueRQ
	return r
}

func (r ApiUnlinkExternalIssuesRequest) Execute() ([]OperationCompletionRS, *http.Response, error) {
	return r.ApiService.UnlinkExternalIssuesExecute(r)
}

/*
UnlinkExternalIssues Unlink external issue for specified test items

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectName
	@return ApiUnlinkExternalIssuesRequest
*/
func (a *TestItemAPIService) UnlinkExternalIssues(ctx context.Context, projectName string) ApiUnlinkExternalIssuesRequest {
	return ApiUnlinkExternalIssuesRequest{
		ApiService:  a,
		ctx:         ctx,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return []OperationCompletionRS
func (a *TestItemAPIService) UnlinkExternalIssuesExecute(r ApiUnlinkExternalIssuesRequest) ([]OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.UnlinkExternalIssues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/issue/unlink"
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unlinkExternalIssueRQ == nil {
		return localVarReturnValue, nil, reportError("unlinkExternalIssueRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unlinkExternalIssueRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTestItemRequest struct {
	ctx              context.Context
	ApiService       *TestItemAPIService
	itemId           int64
	projectName      string
	updateTestItemRQ *UpdateTestItemRQ
}

func (r ApiUpdateTestItemRequest) UpdateTestItemRQ(updateTestItemRQ UpdateTestItemRQ) ApiUpdateTestItemRequest {
	r.updateTestItemRQ = &updateTestItemRQ
	return r
}

func (r ApiUpdateTestItemRequest) Execute() (*OperationCompletionRS, *http.Response, error) {
	return r.ApiService.UpdateTestItemExecute(r)
}

/*
UpdateTestItem Update test item

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId
	@param projectName
	@return ApiUpdateTestItemRequest
*/
func (a *TestItemAPIService) UpdateTestItem(ctx context.Context, itemId int64, projectName string) ApiUpdateTestItemRequest {
	return ApiUpdateTestItemRequest{
		ApiService:  a,
		ctx:         ctx,
		itemId:      itemId,
		projectName: projectName,
	}
}

// Execute executes the request
//
//	@return OperationCompletionRS
func (a *TestItemAPIService) UpdateTestItemExecute(r ApiUpdateTestItemRequest) (*OperationCompletionRS, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationCompletionRS
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestItemAPIService.UpdateTestItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{projectName}/item/{itemId}/update"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectName"+"}", url.PathEscape(parameterValueToString(r.projectName, "projectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateTestItemRQ == nil {
		return localVarReturnValue, nil, reportError("updateTestItemRQ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateTestItemRQ
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
